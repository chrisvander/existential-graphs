{"version":3,"sources":["verifySentence.js","converters.js","canvas/Toolbox.js","canvas/StepMenu.js","canvas/config.js","canvas/EGVariable.js","canvas/EGCut.js","canvas/Canvas.js","intro/CreateNew.js","intro/IntroWindow.js","App.js","serviceWorker.js","index.js"],"names":["require","binary","unary","arrToRegex","arr","map","el","replace","join","uReg","Object","keys","regexStr","binaryRegex","RegExp","atomicRegex","parenthesisRegex","sentence","verifyRecursive","res","match","exec","operators","escapeRegExp","string","binaryOperators","binarySymbReplace","unaryOperators","countUnary","statement","matchesList","val","op","c","split","some","charAt","stripUnary","s","convertStatement","substr","convertToEG","repeat","formula","String","verifySentence","parenthesis","left","right","eg","getMatchingParen","start","parens","j","length","Toolbox","props","state","functions","str","func","highlight","this","hidden","Fragment","className","ref","canvas","onClick","setSelection","React","Component","StepMenu","event","step","disabled","preventDefault","setStep","hide","currentStep","stepInfo","backEnabled","forwardEnabled","style","color","getColor","handleClick","src","gridSize","cutPadding","horizontal","vertical","cutCornerRadius","initialSeparation","EGVariable","text","createRef","getCoords","bind","x","y","cursorOver","dragging","panzoom","window","addEventListener","onMouseMove","handleDragStart","handleDragEnd","enableHighlight","selectedCallback","id","setState","current","cursor","evt","pause","resume","setCoords","clientX","clientY","Math","round","config","removeEventListener","pointerEvents","interaction","fill","onMouseEnter","onMouseLeave","children","EGCut","cut","BB","getBBoxData","update","bounding","_x","_y","_w","_h","getBBox","width","height","interval","setInterval","setTimeout","clearInterval","childEl","fillOpacity","strokeOpacity","stroke","rx","toString","ry","nanoid","Canvas","canvasContainer","renderStep","changePos","getSVGCoords","highlightCut","startSelection","proof","premises","conclusion","steps","data","moveListeners","highlights","var","cbFunction","insert","console","log","erase","erasure","iterate","dcRemove","doubleCutRemove","dcAdd","doubleCutAdd","selectable","nameOfFunction","copyStep","erased","findID","parent","findParent","index","indexOf","splice","push","ID","inside","cut1_id","cut2_id","cut1","type","level","changeCutLevel","concat","cutID","firstCut","secondCut","newContents","change","idFound","changeLevelMap","mapID","changeLevelArray","a","oldStep","newStep","copyDataMap","oldData","newData","d","copyDataArray","h","w","searchedStep","findInArray","findInMap","findIDArray","findIDMap","Array","assign","odd","stepIndex","renderRecurse","jsx","groupElement","unshift","highlightVar","setXY","key","Panzoom","maxZoom","minZoom","vw","max","document","documentElement","clientWidth","innerWidth","vh","clientHeight","innerHeight","currentX","maxX","maxY","stepZero","initXYRecurse","gapSize","X","initXY","convertToArray","i","subExp","moveTo","zoomTo","domX","domY","pt","createSVGPoint","matrixTransform","getScreenCTM","inverse","zoomWithWheel","onWheel","CreateNew","handleChange","removePremise","verify","create","e","target","value","setupFunc","tex","symbol","convertToTeX","closeBtn","formulaInput","onChange","math","getFormulaCell","IntroContent","IntroWindow","createView","callCreate","animateAway","createShown","floatingWindowCSS","App","createNewProof","setupProof","openCanvas","saveProof","introWindow","initialCSS","canvasOpen","popupOpen","Boolean","location","hostname","ReactDOM","render","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","error","message"],"mappings":"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","file":"static/js/main.a45bcf8e.chunk.js","sourcesContent":["/* \n * Return a boolean indicating if the inputted sentence is \n * a correctly formatted. Utilizes a recursive technique,\n * evaluating each sentence as though it were an atomic\n * sentence or any phi and psi combined with a binary \n * operator. \n*/\n\nconst { binary, unary } = require('./operators.json')\n\nfunction escapeRegExp(string) {\n  return string.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&'); // $& means the whole matched string\n}\n\nfunction arrToRegex(arr) {\n  arr = arr.map(el => escapeRegExp(el));\n  return '(?:' + arr.join('|') + ')'\n} \n\nconst uReg = arrToRegex(Object.keys(unary));\nconst regexStr = `^(${uReg}*[A-Za-z]+|${uReg}*\\\\((.*)\\\\))(${arrToRegex(Object.keys(binary))})(${uReg}*[A-Za-z]+|${uReg}*\\\\((.*)\\\\))$`\nlet binaryRegex = new RegExp(regexStr) // eslint-disable-line\nlet atomicRegex = new RegExp(`^${uReg}*[A-Za-z]+$`)\nlet parenthesisRegex = new RegExp(`^${uReg}*\\\\((.*)\\\\)$`)\n\nfunction verifyRecursive(sentence) {\n  let res\n  if (sentence.match(atomicRegex)) return true;\n  else if ((res = binaryRegex.exec(sentence)) !== null) {\n    if (res == null) return false;\n    if (res[2] && res[5]) \n      return verifyRecursive(res[2]) && verifyRecursive(res[5]);\n    else if (res[2]) \n      return verifyRecursive(res[2]);\n    else if (res[5]) \n      return verifyRecursive(res[5]);\n    else return true;\n  } else if ((res = parenthesisRegex.exec(sentence)) !== null)\n    return verifyRecursive(res[1])\n}\n\nexport {\n  binaryRegex,\n  atomicRegex,\n  parenthesisRegex\n}\n\nexport default (sentence) => {\n  // filter out spaces\n  sentence = sentence.replace(/\\s/g, '')\n  return verifyRecursive(sentence);\n}","import verifySentence, { \n  parenthesisRegex, \n  binaryRegex,\n  atomicRegex\n} from './verifySentence';\n\nconst operators = require('./operators.json')\n\nfunction escapeRegExp(string) {\n  return string.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&'); // $& means the whole matched string\n}\n\nconst binaryOperators = operators.binary\nlet keys = Object.keys(binaryOperators);\nkeys = keys.map(el => escapeRegExp(el));\nconst binarySymbReplace = new RegExp('(?:' + keys.join('|') + ')', 'g')\n\nconst unaryOperators = operators.unary\n\nconst convertToTeX = (formula) => {\n  if (typeof formula === 'string' || formula instanceof String) {\n    // filter out spaces\n    formula = formula.replace(/\\s/g, '')\n    let symbol\n    // replace all binary operators\n    while ((symbol = binarySymbReplace.exec(formula)) !== null) {\n      formula = formula.substr(0,symbol['index']) \n                    + binaryOperators[symbol[0]] + ' '\n                    + formula.substr(symbol['index'] + symbol[0].length);\n    }\n    // replace all unary operators\n    for (let i in Object.keys(unaryOperators)) {\n      symbol = Object.keys(unaryOperators)[i];\n      formula = formula.replace(new RegExp(escapeRegExp(symbol), 'g'), unaryOperators[symbol] + ' ');\n    }\n    // filter out all other characters\n    formula = formula.replace(/[^()A-Za-z\\\\\\s]/g, '')\n    return formula\n  }\n  else return \"\"\n}\n\nfunction countUnary(statement) {\n  const matchesList = (val) => (op) => op === val;\n  let c = 0;\n  for (c in statement.split(\"\"))\n    if (!Object.keys(unaryOperators).some(matchesList(statement.charAt(c))))\n      break;\n  return c;\n}\n\nconst stripUnary = (s, convertStatement) => {\n  if (convertStatement == null) \n    convertStatement = true;\n  let c = countUnary(s);\n  let statement = s.substr(c)\n  if (convertStatement) statement = convertToEG(statement)\n  else statement = '{' + statement + '}'\n  return \"(\".repeat(c) + statement + \")\".repeat(c)\n}\n\nconst convertToEG = (formula) => {\n  if ((typeof formula === 'string' || formula instanceof String) && verifySentence(formula)) {\n    // filter out spaces\n    formula = formula.replace(/\\s/g, '')\n    let binary = binaryRegex.exec(formula)\n    let parenthesis = parenthesisRegex.exec(formula)\n    let unary = atomicRegex.exec(formula)\n    if (binary) {\n      let left = convertToEG(binary[1])\n      let right = convertToEG(binary[4])\n      let symConversion = operators.eg[binary[3]];\n      return symConversion.replace(/\\$1/g, left).replace(/\\$2/g, right)\n    } else if (parenthesis) {\n      if (countUnary(formula) != 0) {\n        return stripUnary(formula)\n      }\n      return convertToEG(parenthesis[1]);\n    } else if (unary) {\n      return stripUnary(formula, false);\n    } else return null;\n  }\n  else return null;\n}\n\n/*  Given a string and the index of the open parenthesis, this\n *  will return the index of the closed parenthesis\n */\nconst getMatchingParen = (formula, start) => {\n  // hold the number of '(' minus the number of ')'\n  let parens = 0\n  let j = start\n  while (j < formula.length) {\n    if (formula[j] === '(') {\n      parens++\n    }\n    else if (formula[j] === ')') {\n      parens--\n      // if parens is 0, then the current ')' matches the start parenthesis\n      if (parens === 0)\n        return j\n    }\n    j++\n  }\n}\n\n/*  Converts a string representing an Existential Graph into\n *  a nested array. Acts recursively, calling iteslf again\n *  When a pair of parentehses are found. If given an index i,\n *  this will start from that index.\n *  For example: \n *  \"((({P})){Q}{R}){P}\" => [ [ [['P']],'Q','R' ],'P' ]\n */\nconst convertToArray = (formula, i = 0) => {\n  if (typeof formula === 'string' || formula instanceof String) {\n    // hold the array of the current level that will be returned\n    let arr = []\n    // loop through the string\n    while (i < formula.length) {\n      // if closing parenthesis, return the array for this subexpression\n      if (formula[i] === '(') {\n        // find the matching pair of parentheses of the subexpression\n        let j = getMatchingParen(formula, i)\n        // push the subexpression into the array\n        let subExp = formula.substr(i+1, j-1)\n        if (subExp)\n          arr.push(convertToArray(formula.substr(i+1, j-1)))\n        i = j\n      }\n      // if a variable is found, push it to the array\n      else if (formula[i] === '{') {\n        let text = formula[++i];\n        if (text === '}') arr.push('\\u00A0')\n        else arr.push(text)\n        i++\n      }\n      i++\n    }\n    // return the array that values the current expression\n    return arr\n  }\n  else return null\n}\n\nexport {\n  convertToTeX,\n  convertToEG,\n  convertToArray,\n  verifySentence\n}","import React from 'react';\n\nclass Toolbox extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      functions: [\n        {\n          str: \"Iterate/Deiterate\",\n          func: 'iterate',\n          highlight: { 'cut': 'all' }\n        },\n        {\n          str: \"Remove Double Cut\",\n          func: 'dcRemove',\n          highlight: { 'cut': 'all' }\n        },\n        {\n          str: \"Add Double Cut\",\n          func: 'dcAdd',\n          highlight: { 'cut': 'all', 'var': 'all' }\n        },\n        {\n          str: \"Insertion\",\n          func: 'insert',\n          highlight: { 'cut': 'odd', 'var': 'odd' }\n        },\n        {\n          str: \"Erasure\",\n          func: 'erase',\n          highlight: { 'cut': 'even', 'var': 'even' }\n        }\n      ]\n    };\n  }\n\n  componentDidMount() {  \n  }\n\n  render() {\n    if (this.props.hidden) return <React.Fragment />;\n    return (\n      <div className=\"toolbox\" ref={this.canvas}>\n        <h3>Tools</h3>\n        {this.state.functions.map(el => (\n          <div className=\"tool\" onClick={() => this.props.setSelection(el.highlight, el.func)}>{el.str}</div>\n        ))}\n      </div>\n    );\n  }\n}\n\nexport default Toolbox;","import React from 'react';\nimport { ReactSVG } from 'react-svg';\n\nclass StepMenu extends React.Component {\n  handleClick(event, step, disabled) {\n    event.preventDefault();\n    if (!disabled) {\n      // Must update color before updating props to allow component to\n      // render with the proper current color rather than the state before\n      this.props.setStep(step);\n    }\n  }\n\n  getColor(disabled) {\n    return disabled ? \"rgb(136, 136, 136)\" : \"rgb(68, 68, 68)\";\n  }\n\n  render() {\n    let { hide, currentStep, stepInfo } = this.props;\n    if (hide) return (<React.Fragment />);\n    let backEnabled = currentStep === (stepInfo.length - 1);\n    let forwardEnabled = currentStep === 0;\n    return (\n      <React.Fragment>\n        <div className=\"step-menu\">\n        <div style={{ color: this.getColor(forwardEnabled)}}>\n          <div onClick={(event) => this.handleClick(event, 0, forwardEnabled)}>\n            <ReactSVG src=\"/assets/step-first.svg\"/>\n          </div>\n          <div onClick={(event) => this.handleClick(event, currentStep - 1, forwardEnabled)}>\n            <ReactSVG src=\"/assets/step-prev.svg\" />\n          </div>\n        </div>\n        <div style={{ color: this.getColor(backEnabled)  }}>\n          <div onClick={(event) => this.handleClick(event, currentStep + 1, backEnabled)}>\n            <ReactSVG src=\"/assets/step-next.svg\" />\n          </div>\n          <div onClick={(event) => this.handleClick(event, stepInfo.length - 1, backEnabled)}>\n            <ReactSVG src=\"/assets/step-last.svg\" />\n          </div>\n        </div>\n        </div>\n        <div className=\"step-text\">\n          Step {currentStep + 1} of {stepInfo.length}\n        </div>\n      </React.Fragment>\n    );\n  }\n}\n\nexport default StepMenu;","export default {\n  gridSize: 1,\n  cutPadding: {\n    horizontal: 10,\n    vertical: 5\n  },\n  cutCornerRadius: 10,\n  initialSeparation: 50,\n}","import React from 'react';\nimport config from './config';\n\nclass EGVariable extends React.Component {\n  constructor(props) {\n    super(props);\n    this.text = React.createRef()\n    this.getCoords = this.props.getCoords\n    this.handleClick = this.handleClick.bind(this);\n    this.state = {\n      x: props.x,\n      y: props.y,\n      cursorOver: false,\n      dragging: false\n    };\n\n    this.panzoom = this.props.panzoom\n\n    window.addEventListener('mousemove', this.onMouseMove.bind(this))\n    window.addEventListener('mousedown', this.handleDragStart.bind(this))\n    window.addEventListener('mouseup', this.handleDragEnd.bind(this))\n    window.addEventListener('click', this.handleClick)\n  }\n\n  handleClick() {\n    if (this.state.cursorOver \n      && this.props.enableHighlight \n      && this.props.selectedCallback) \n    {\n      this.props.selectedCallback(this.props.id);\n      this.setState({ cursorOver: false });\n    }\n  }\n\n  componentDidMount() {  \n    this.text.current.style.cursor = \"pointer\";\n  }\n\n  handleDragStart(evt) {\n    if (this.state.cursorOver) {\n      this.panzoom.pause()\n      this.setState({ dragging: true })\n    }\n  }\n\n  handleDragEnd(evt) {\n    this.panzoom.resume()\n    let { x, y } = this.state;\n    this.props.setCoords(x, y);\n    this.setState({ dragging: false })\n  }\n\n  onMouseMove(evt) {\n    if (this.state.dragging) {\n      let { x, y } = this.getCoords(evt.clientX, evt.clientY)\n      x = Math.round(x/config.gridSize)*config.gridSize\n      y = Math.round(y/config.gridSize)*config.gridSize\n      this.props.setCoords(x, y);\n      this.setState({ x: x, y: y })\n    }\n  }\n\n  componentWillUnmount() {\n    window.removeEventListener('click', this.handleClick);\n    window.removeEventListener('mousemove', this.onMouseMove.bind(this))\n    window.removeEventListener('mousedown', this.handleDragStart.bind(this))\n    window.removeEventListener('mouseup', this.handleDragEnd.bind(this))\n  }\n\n  render() {\n    let highlight = this.state.cursorOver && this.props.enableHighlight;\n    return (\n      <text \n        className=\"noselect\"\n        pointerEvents={this.props.interaction ? null : 'none'}\n        x={this.state.x} \n        y={this.state.y} \n        id={this.props.id}\n        fill={highlight ? \"blue\" : \"black\"}\n        onMouseEnter={() => this.setState({ cursorOver: true })}\n        onMouseLeave={() => this.setState({ cursorOver: false })}\n        ref={this.text}>\n        {this.props.children}\n      </text>\n    );\n  }\n}\n\nexport default EGVariable;","import React from 'react';\nimport config from './config';\n\nclass EGCut extends React.Component {\n  constructor(props) {\n    super(props);\n    this.cut = React.createRef();\n    this.BB = React.createRef();\n    this.getBBoxData = this.getBBoxData.bind(this);\n    this.handleClick = this.handleClick.bind(this);\n    this.update = this.update.bind(this);\n    this.state = { highlight: false, bounding: {_x:0,_y:0,_w:0,_h:0} };\n\n    window.addEventListener('click', this.handleClick)\n  }\n\n  handleClick() {\n    if (this.state.highlight \n      && this.props.enableHighlight \n      && this.props.selectedCallback) \n    {\n      this.props.selectedCallback(this.props.id);\n      this.setState({ highlight: false });\n    }\n  }\n\n  getBBoxData() {\n    if (this.cut.current) {\n      let { x, y, width, height } = this.cut.current.getBBox();\n      let _x = x - config.cutPadding.horizontal;\n      let _y = y - config.cutPadding.vertical;\n      let _w = width + config.cutPadding.horizontal * 2;\n      let _h = height + config.cutPadding.vertical * 2;\n      return { _x, _y, _w, _h };\n    }\n    return {};\n  }\n\n  update() {\n    if (!this.interval) {\n      this.interval = setInterval(() => {\n        this.setState({ bounding: this.getBBoxData() });\n      }, 1);\n      setTimeout(() => {\n        clearInterval(this.interval);\n        this.interval = null;\n      }, 100);\n    }\n  }\n\n  componentDidMount() { \n    this.update()\n  }\n\n  componentDidUpdate() {\n    this.update()\n  }\n\n  componentWillUnmount() {\n    window.removeEventListener('click', this.handleClick);\n    if (this.interval)\n      clearInterval(this.interval);\n  }\n\n  render() {\n    let childEl = this.props.children;\n    if (childEl.length < 1) {\n      childEl = <EGCut>{\" \"}</EGCut>\n    }\n    let highlight = this.state.highlight && this.props.enableHighlight;\n    let { _x, _y, _w, _h } = this.state.bounding;\n    return (\n      <React.Fragment>\n        <rect\n          x={_x}\n          y={_y}\n          width={_w}\n          height={_h}\n          fillOpacity=\"0.7\" \n          strokeOpacity=\"1\"\n          stroke=\"black\"\n          fill={highlight ? \"#9AA899\" : \"white\"}\n          onMouseEnter={() => this.setState({ highlight: true })}\n          onMouseLeave={() => this.setState({ highlight: false })}\n          rx={config.cutCornerRadius.toString()} \n          ry={config.cutCornerRadius.toString()}\n        />\n        <g ref={this.cut}>\n          {this.props.children}\n        </g>\n      </React.Fragment>\n    );\n  }\n}\n\nexport default EGCut;","import React from 'react';\nimport { convertToArray } from '../converters';\nimport Toolbox from './Toolbox';\nimport StepMenu from './StepMenu';\nimport EGVariable from './EGVariable';\nimport EGCut from './EGCut';\nimport './Canvas.scss';\nimport Panzoom from 'panzoom';\nimport config from './config';\nimport { NotificationContainer, NotificationManager } from 'react-notifications';\nconst nanoid = require('nanoid').nanoid;\n\n// some defaults: \n//    <text> blocks are automatically 22px high\n\nconst TEXT_H = 22;\n\nfunction initXY(step, level) {\n  let data = {}\n  let currentX = 0\n  let currentY = 0\n  let maxX = 0\n  let maxY = 0\n\n  // gapSize should be equal to the number of level changes\n  // in between two variables, so that we can evenly place \n  // them initially across the screen\n  function initXYRecurse(step, level, gapSize) {\n    console.log(data)\n    for (let s in step) {\n      if (step[s] instanceof Array && step[s].length > 0) {\n        let id = nanoid()\n        step[s] = { data: initXYRecurse(step[s], level + 1), id: id, type: \"cut\" }\n        data[id] = { type: \"cut\", level: level }\n      } else {\n        let X = currentX;\n        let Y = currentY;\n        let id = nanoid()\n        data[id] = { \n          type: \"var\",\n          var: step[s], \n          x: Math.round(X/config.gridSize)*config.gridSize, \n          y: Math.round(Y/config.gridSize)*config.gridSize,\n        }\n        step[s] = id\n        maxY = Y > maxY ? Y : maxY;\n        maxX = X > maxX ? X : maxX;\n        currentX += config.initialSeparation\n      }\n    }\n    return step\n  }\n  return { stepZero: { data: initXYRecurse(step, level), h: maxY + TEXT_H, w: maxX }, data: data }\n}\n\nclass Canvas extends React.Component {\n  constructor(props) {\n    super(props);\n    this.canvas = React.createRef();\n    this.canvasContainer = React.createRef();\n\n    this.renderStep = this.renderStep.bind(this);\n    this.changePos = this.changePos.bind(this);\n    this.getSVGCoords = this.getSVGCoords.bind(this);\n    this.highlightCut = this.highlightCut.bind(this);\n    this.startSelection = this.startSelection.bind(this);\n\n    let { premises, conclusion, steps, data } = this.props.proof;\n    this.state = {\n      proof: {\n        premises: premises,\n        conclusion: conclusion\n      },\n      steps: steps || [],\n      data: data || {},\n      currentStep: 0,\n      moveListeners: [],\n      highlights: {\n        cut: 'none', // 'none', 'odd', 'even', 'all'\n        var: 'none'\n      },\n      cbFunction: null,\n      interaction: true,\n      functions: {\n        insert: (id) => {\n          console.log(\"INSERTION\")\n        },\n        erase: (id) => {\n          console.log(\"ERASURE\")\n          return this.erasure(id);\n        },\n        iterate: (id) => {\n          console.log(\"ITERATION\")\n        },\n        dcRemove: (id) => {\n          console.log(\"DOUBLE CUT Remove\")\n          return this.doubleCutRemove(id);\n        },\n        dcAdd: (id) => {\n          console.log(\"DOUBLE CUT Add\")\n          return this.doubleCutAdd(id);\n          \n        }\n      }\n    }\n  }\n\n  startSelection(selectable, nameOfFunction) {\n    let { steps, currentStep } = this.state;\n    // only allow steps to be conducted at the end of a proof\n    if (currentStep+1 !== steps.length) {\n      return\n    }\n    this.setState({ \n      highlights: selectable, \n      interaction: false, \n      cbFunction: (id) => {\n        let successful = this.state.functions[nameOfFunction](id); \n        if (successful) \n          this.setState({ \n            highlights: {\n              cut: 'none', \n              var: 'none'\n            },\n            interaction: true, \n            cbFunction: null });\n      }\n    });\n  }\n\n  erasure(id) {\n    let { steps, currentStep, data } = this.state;\n    // Create a new step\n    let step = this.copyStep(steps[currentStep]);\n    // Find the data that will be erased\n    let erased = this.findID(step, id);\n    console.log(erased)\n    if (!erased) {\n      return false;\n    }\n    // Get the parent of the erased section\n    let parent = this.findParent(step, id)\n    if (!parent) {\n      return false;\n    }\n    // Remove the erased data from the parent's data array\n    const index = parent.data.indexOf(erased);\n    if (index > -1)\n      parent.data.splice(index, 1);\n    else {\n      return false;\n    }\n    // Update the state\n    currentStep+=1;\n    steps.push(step);\n    this.setState({ steps: steps, currentStep: currentStep, data:data });\n    return true;\n  }\n\n  /* Adds a double cut given the ID of the data that will be inside the cut.\n  *  Will only run if the current step is the last step.\n  */\n  doubleCutAdd(ID) {\n    let { steps, currentStep, data } = this.state;\n    // create a new step\n    let step = this.copyStep(steps[currentStep]);\n    // use findID to find the data represented by the id\n    // this is the data that will be inside the two new cuts\n    let inside = this.findID(step, ID);\n    if (!inside) {\n      return false;\n    }\n    // create a new cut with another one inside it\n    let cut1_id = nanoid();\n    let cut2_id = nanoid();\n    let cut2 = {\n      data: [inside],\n      id: cut2_id,\n      type: \"cut\"\n    }\n    let cut1 = {\n      data: [cut2],\n      id: cut1_id,\n      type: \"cut\"\n    }\n    // Set the levels of the two cuts\n    let level = data[ID].level\n    data[cut2_id] = { type: \"cut\", level: level };\n    data[cut1_id] = { type: \"cut\", level: level + 1 };\n    // increase the level of the inside cut along with all cuts inside of it by 2\n    this.changeCutLevel(step, ID, 2)\n\n    // get the parent of the selection\n    let parent = this.findParent(step, ID)\n    if (!parent) {\n      return false;\n    }\n    // Add the contents of the new cuts to the data array\n    // after removing the original contents\n    const index = parent.data.indexOf(inside);\n    if (index > -1) {\n      parent.data.splice(index, 1);\n    }\n    parent.data = parent.data.concat(cut1);\n    // Change the state data accordingly\n    currentStep+=1;\n    steps.push(step);\n    this.setState({ steps: steps, currentStep: currentStep, data:data });\n    return true;\n  }\n\n  /* Removes a double cut given the ID of the outside cut.\n  *  Will only run if the current step is the last step.\n  *  Creates a deep copy of the current step, and replaces the cut with\n  *  the given ID with the contents of the second cut, only if they exist.\n  *  Then adds the edited copy of the current step to the end of the step array.\n  */\n  doubleCutRemove(cutID) {\n    let { steps, currentStep, data } = this.state;\n    // Create a new step\n    let step = this.copyStep(steps[currentStep]);\n\n    // use findID to find the cut with the given ID\n    let firstCut = this.findID(step, cutID);\n    // If it is actually a cut and has another cut inside\n    if (firstCut && firstCut.type === \"cut\") {\n      let secondCut = firstCut.data;\n      if (secondCut && secondCut.length === 1 && secondCut[0].type === \"cut\") {\n        // Get the data inside the second cut\n        let newContents = secondCut[0].data;\n        // Get the parent of the original cut being removed\n        let parent = this.findParent(step, cutID)\n        if (!parent) {\n          return false;\n        }\n        // Remove the first cut from the data array\n        const index = parent.data.indexOf(firstCut);\n        if (index > -1) {\n          parent.data.splice(index, 1);\n        }\n        // Add the contents of the second cut to the data array\n        parent.data = parent.data.concat(newContents);\n        // Update the state\n        currentStep+=1;\n        steps.push(step);\n        this.setState({ steps: steps, currentStep: currentStep, data:data });\n        return true;\n      }\n      else return false;\n    }\n    else return false;\n  }\n\n  /* Given a step and the ID of a cut, will iterate through all cuts within\n   * that cut and change their level by a specified amount.\n  */\n  changeCutLevel(step, id, change) {\n    let { data } = this.state\n    // when true, the levels should change in the functions below\n    let idFound = false\n    // Changes the \n    function changeLevelMap(map) {\n      // get the id for the current map\n      let mapID;\n      if (map.id) {\n        mapID = map.id\n        // if it matches the id being searched, update the boolean\n        if (mapID === id) {\n          idFound = true;\n        }\n      }\n      // If the ID has been found, update the level of the current cut\n      if (idFound) {\n        data[mapID].level += change;\n      }\n      // call the function of the data array if it exists\n      if (map.data){\n        changeLevelArray(map.data);\n      }\n    }\n    function changeLevelArray(arr) {\n      for (let a in arr) {\n        // If a non-string is found (a cut)\n        if (typeof arr[a] !== 'string') {\n          // Change the level of the cut\n          changeLevelMap(arr[a])\n        }\n      }\n    }\n    changeLevelArray(step.data)\n    this.setState({ data: data })\n  }\n\n  // Performs a deep copy of oldStep into newStep, used to not change previous steps\n  // By allowing them to be copied without using a reference\n  copyStep(oldStep) {\n    let newStep = {};\n    function copyDataMap(oldData) {\n      let newData = {};\n      for (let d in oldData) {\n        // If an id or type if found, copy directly\n        if(typeof oldData[d] === 'string') {\n          newData[d] = oldData[d];\n        }\n        // Otherwise if an array is found, copy using helper function\n        else {\n          newData[d] = copyDataArray(oldData[d]);\n        }\n      }\n      return newData;\n    }\n    function copyDataArray(oldData) {\n      let newData = [];\n      for (let d in oldData) {\n        // If an ID is found (variable), copy directly\n        if(typeof oldData[d] === 'string') {\n          newData.push(oldData[d]);\n        }\n        // If a map was found (cut), copy using helper function\n        else {\n          newData.push(copyDataMap(oldData[d]));\n        }\n      }\n      return newData;\n    }\n    // Copy the data, width, and height of the original into the new step\n    newStep.data = copyDataArray(oldStep.data);\n    newStep.h = oldStep.h;\n    newStep.w = oldStep.w;\n    return newStep;\n  }\n\n  /* Finds and returns the item that is the parent of the item\n   * with the specified ID, given the step to search as well.\n  */\n  findParent(searchedStep, id) {\n    // holds the parent of the id\n    let parent = searchedStep\n    // Searches an array for the ID, returns true if it is found\n    function findInArray(arr) {\n      for (let a in arr) {\n        // If an ID is found, compare it\n        if (typeof arr[a] === 'string') {\n          if (arr[a] === id) {\n            return true;\n          }\n        }\n        // Otherwise if a datamap is found, check the ID\n        else {\n          // If ID matches, return true\n          if (arr[a].id && arr[a].id === id) {\n            return true;\n          }\n          // Otherwise, search the datamap\n          else {\n            findInMap(arr[a])\n          }\n        }\n      }\n      return false;\n    }\n    function findInMap(map) {\n      // if the map contains data, search the data\n      if (map.data) {\n        // if found, set parent to this map\n        if(findInArray(map.data)) {\n          parent = map;\n        }\n      }\n    }\n    findInArray(searchedStep.data);\n    return parent;\n  }\n\n  // finds and returns the item with the specified ID in a given step\n  findID(searchedStep, id) {\n    // Find the ID in an array\n    function findIDArray(arr) {\n      for (let a in arr) {\n        // if a string, aka an ID\n        if (typeof arr[a] === 'string') {\n          // return the ID if found\n          if (arr[a] === id) {\n            return id;\n          }\n        }\n        // if a data map is found with the correct id, return the data map\n        else if (arr[a].id === id) {\n          return arr[a];\n        // otherwise, call findID step on the datamap that has the incorrect ID\n        } else {\n          let s = findIDMap(arr[a]);\n          if (s)\n            return s;\n        }\n      }\n    }\n    // Finds the ID in a data map representing a step\n    function findIDMap(step) {\n      for (let s in step) {\n        // if an array is found, call findIDArray on each element\n        if (step[s] instanceof Array) {\n          return findIDArray(step[s]);\n        // if an id is found, check if it matches and return the data if so\n        } else if (s === \"id\") {\n          if (step[s] === id)\n            return step;\n        }\n      }\n    }\n    return findIDMap(searchedStep);\n  }\n\n  changePos(id, x, y) {\n    let { data } = this.state;\n    Object.assign(data[id], { x: x, y: y })\n    this.setState(data)\n  }\n\n  highlightCut(level) {\n    if (this.state.highlights.cut === 'all') return true;\n    let odd = false;\n    if (level % 2 === 1) odd = true;\n    if (this.state.highlights.cut === 'odd' && odd) return true;\n    else if (this.state.highlights.cut === 'even' && !odd) return true;\n    return false;\n  }\n\n  highlightVar(level) {\n    if (this.state.highlights.var === 'all') return true;\n    let odd = false;\n    if (level % 2 === 1) odd = true;\n    if (this.state.highlights.var === 'odd' && odd) return true;\n    else if (this.state.highlights.var === 'even' && !odd) return true;\n    return false;\n  }\n\n  renderStep(stepIndex) {\n    let { data } = this.state;\n    let step = this.state.steps[stepIndex]\n    if (step) {\n      const setXY = (id,x,y) => {\n        data[id].x = x;\n        data[id].y = y;\n        this.setState({ data: data })\n      }\n\n      const renderRecurse = (step) => {\n        let jsx = [];\n        for (let s in step) {\n          if (step[s].type === \"cut\") {\n            let level = data[step[s].id].level;\n            let groupElement = (\n              <EGCut \n                level={level} \n                enableHighlight={this.highlightCut(level)}\n                id={step[s].id}\n                selectedCallback={this.state.cbFunction}>\n                {renderRecurse(step[s].data)}\n              </EGCut>\n            );\n            jsx.push(groupElement);\n          } else {\n            let el = this.state.data[step[s]];\n            let level = data[step[s]].level;\n            jsx.unshift(\n              <EGVariable \n                x={el.x} \n                y={el.y} \n                id={step[s]} \n                enableHighlight={this.highlightVar(level)}\n                selectedCallback={this.state.cbFunction}\n                panzoom={this.panzoom}\n                interaction={this.state.interaction || this.highlightVar(level)}\n                getCoords={this.getSVGCoords}\n                setCoords={(x,y) => setXY(step[s],x,y)}\n                key={step[s]}>\n                {el.var}\n              </EGVariable>\n            );\n          }\n        }\n        return jsx;\n      }\n      renderRecurse.bind(this);\n      return renderRecurse(step.data)\n    }\n  }\n\n  componentDidMount() {  \n\n    this.panzoom = Panzoom(this.canvas.current, {\n      maxZoom: 6,\n      minZoom: 0.5\n    });\n    // this.canvasContainer.current.addEventListener('wheel', this.panzoom.zoomWithWheel);\n    const vw = Math.max(document.documentElement.clientWidth, window.innerWidth || 0);\n    const vh = Math.max(document.documentElement.clientHeight, window.innerHeight || 0);\n    // if there are no existing steps, init first step\n    let { steps } = this.state;\n    if (steps.length === 0) {\n      let { premises, conclusion } = this.state.proof;\n      let { stepZero, data } = initXY(convertToArray(premises.join('')), 0);\n      steps.push(stepZero);\n      this.setState({ steps: steps, data: data });\n    }\n    // required to use setState to trigger re-render after creation of panzoom\n    this.setState({ currentStep: 0 });\n    let step = this.state.steps[this.state.currentStep];\n\n    this.panzoom.moveTo(vw/2 - step.w, vh/2 - step.h);\n    this.panzoom.zoomTo(vw/2 - step.w, vh/2 - step.h, 2);\n  }\n\n  componentWillUnmount() {\n    window.removeEventListener('resize', this);\n  }\n\n  getSVGCoords(domX, domY) {\n    var pt = this.canvasContainer.current.createSVGPoint();\n\n    pt.x = domX;\n    pt.y = domY;\n\n    return pt.matrixTransform(this.canvas.current.getScreenCTM().inverse());\n  }\n\n  render() {\n    let zoomWithWheel = () => {}\n    let { steps, currentStep } = this.state;\n    if (this.panzoom)\n      zoomWithWheel = this.panzoom.zoomWithWheel\n    return (\n      <div>\n        <Toolbox \n          hidden={currentStep+1 !== steps.length}\n          functions={this.state.functions}\n          setSelection={this.startSelection}\n        />\n        <svg \n          ref={this.canvasContainer}\n          className=\"canvas noselect\" \n          onWheel={zoomWithWheel} >\n          <g ref={this.canvas}>\n            {this.panzoom && this.renderStep(this.state.currentStep)}\n          </g>\n        </svg>\n        <StepMenu \n          currentStep={this.state.currentStep} \n          stepInfo={this.state.steps} \n          setStep={s => this.setState({ currentStep: s, interaction: s === this.state.steps.length - 1 })}\n        />\n      </div>\n    );\n  }\n}\n\nexport default Canvas;\n","import React from 'react';\nimport verify from '../verifySentence';\nimport { convertToTeX, convertToEG } from '../converters';\n// KATEX\nimport 'katex/dist/katex.min.css';\nimport TeX from '@matejmazur/react-katex';\nimport './CreateNew.scss';\n\nclass CreateNew extends React.Component {\n  constructor(props) {\n    super(props);\n  \n    this.state = {\n      premises: [\n        ''\n      ],\n      conclusion: ''\n    };\n\n    this.handleChange.bind(this)\n    this.removePremise.bind(this)\n    this.verify = this.verify.bind(this)\n    this.create = this.create.bind(this)\n  }\n\n  componentDidMount() {\n\n  }\n\n  handleChange(e, i) {\n    if (i != null) {\n      let { premises } = this.state;\n      premises[i] = e.target.value;\n      this.setState({ premises: premises })\n    }\n    else this.setState({ conclusion: e.target.value })\n  }\n\n  removePremise(index) {\n    let { premises } = this.state;\n    premises.splice(index, 1);\n    this.setState({ premises: premises })\n  }\n\n  verify() {\n    let { premises, conclusion } = this.state;\n    for (let i in premises) {\n      if (premises[i] === '' || !premises[i])\n        return false;\n    }\n    if (conclusion === '' || !conclusion)\n      return false;\n    return true;\n  }\n\n  create() {\n    console.log(\"Creating...\")\n    console.log(\"Verification concluded \" + this.verify())\n    if (this.verify()) {\n      let { premises, conclusion } = this.state;\n      for (let i in premises) {\n        premises[i] = convertToEG(premises[i])\n        console.log(premises[i])\n      }\n      conclusion = convertToEG(conclusion)\n      this.props.setupFunc(premises, conclusion, [])\n    }\n  }\n\n  getFormulaCell(formula, i) {\n    let tex, eg\n    if (verify(formula)) {\n      tex = convertToTeX(formula);\n      eg = convertToEG(formula);\n    }\n    let closeBtn = <td \n      className=\"close interactive\" \n      onClick={() => this.removePremise(i)}>\n        &#10005;\n      </td>;\n    let formulaInput = <input onChange={ (e) => this.handleChange(e,i) } />;\n    if (i == null) {\n      formulaInput = <input onChange={ (e) => this.handleChange(e) } />;\n      closeBtn = <td className=\"close\"/>;\n    }\n    if (i === 0) \n      closeBtn = <td className=\"close\"/>;\n    return (\n      <tr>\n        <td>\n          {formulaInput}\n        </td>\n        <td>\n          {tex && <TeX math={tex} />}\n        </td>\n        <td>\n          {eg && <TeX math={eg} />}\n        </td>\n        { closeBtn }\n      </tr>\n    );\n  }\n\n  render() {\n    let { premises, conclusion } = this.state;\n    return (\n      <div className=\"content full-width\">\n        <h1>Create New</h1>\n        <h2>File Name</h2>\n        <input />\n        <table className=\"formulaTable\">\n          \n        </table>\n        <h2>Premises</h2>\n        <table className=\"formulaTable\">\n          <tr>\n              <td>\n                Formula\n              </td>\n            <td>TeX notation</td><td>EG notation</td><td className=\"close\"/>\n          </tr>\n          {premises.map((formula,i) => this.getFormulaCell(formula, i))}\n          <tr>\n            <td className=\"interactive\" onClick={() => this.setState({ premises: premises.concat(['']) }) }>\n              <span className=\"plus\" />Add New Premise\n            </td>\n            <td/><td/><td className=\"close\"/>\n          </tr>\n        </table>\n        <h2>Conclusion</h2>\n        <table className=\"formulaTable\">\n          {this.getFormulaCell(conclusion)}\n        </table>\n      </div>\n    );\n  }\n}\n\nexport default CreateNew;","import React from 'react';\nimport CreateNew from './CreateNew';\nimport { ReactSVG } from 'react-svg';\nimport './intro.scss';\n\nconst IntroContent = () => (\n  <div className=\"content\">\n    <div className=\"column\">\n      <h1>Existential Graphs</h1>\n      <p>\n        Using this tool, you can initialize proofs in the existential graph schema and then you can go through the process of solving them. You can save these proofs and look back at them later.\n      </p>\n    </div>\n    <div className=\"divider\" />\n    <div className=\"column\">\n      <h1>Recent Proofs</h1>\n    </div>\n  </div>\n);\n\nclass IntroWindow extends React.Component {\n  constructor(props) {\n    super(props);\n    this.createView = React.createRef();\n    this.callCreate = this.callCreate.bind(this);\n    this.animateAway = this.animateAway.bind(this);\n    this.state = {\n      createShown: false,\n      floatingWindowCSS: 'floating-window shown'\n    };\n  }\n\n  componentDidMount() {\n  }\n\n  animateAway() {\n    this.setState({ floatingWindowCSS: 'floating-window' })\n  }\n\n  callCreate() {\n    this.createView.current.create();\n  }\n\n  render() {\n    const { createShown, floatingWindowCSS } = this.state;\n    return (\n      <div className={floatingWindowCSS}>\n        {!createShown && <IntroContent />}\n        {createShown && <CreateNew setupFunc={this.props.setupFunc} ref={this.createView}/>}\n          {!createShown && (\n            <div className=\"toolbar\">\n            <button onClick={() => this.setState({ createShown: true })}>\n              New \n            </button>\n            <button>\n              Open \n            </button>\n            </div>\n          )}\n          {createShown && (\n            <div className=\"toolbar\">\n              <button className=\"back\" onClick={() => this.setState({ createShown: false })}>\n                <span >\n                  <ReactSVG className=\"svg\" src=\"/assets/back-caret.svg\" />\n                </span>\n                Back \n              </button>\n              <button onClick={this.callCreate}>\n                Create \n              </button>\n            </div>\n          )}\n      </div>\n    );\n  }\n}\n\nexport default IntroWindow;","import React from 'react';\nimport './App.scss';\nimport Canvas from './canvas/Canvas';\nimport IntroWindow from './intro/IntroWindow';\n\nclass App extends React.Component {\n  constructor(props) {\n    super(props);\n  \n    this.createNewProof = this.createNewProof.bind(this);\n    this.setupProof = this.setupProof.bind(this);\n    this.openCanvas = this.openCanvas.bind(this);\n    this.saveProof = this.saveProof.bind(this);\n    this.introWindow = React.createRef();\n    // this.state = {\n    //   initialCSS: 'initial',\n    //   canvasOpen: false,\n    //   popupOpen: false,\n    //   proof: {\n    //     premises: [],\n    //     conclusion: '',\n    //     steps: []\n    //   }\n    // };\n    this.state = {\n      initialCSS: 'initial',\n      canvasOpen: true,\n      popupOpen: false,\n      proof: {premises: [\"({Q})(({P}){Q})\"], conclusion: \"{Q}\", steps:[] }\n    };\n  }\n\n  saveProof(proof) {\n    this.setState({ proof: proof });\n  }\n\n  setupProof(premises, conclusion, steps) {\n    this.setState({ \n      proof: { \n        premises: premises,\n        conclusion: conclusion,\n        steps: steps\n      },\n      initialCSS: 'initial whiteBG'\n    });\n    this.introWindow.current.animateAway();\n    setTimeout(this.openCanvas, 1000);\n  }\n\n  openCanvas() {\n    this.setState({ \n      canvasOpen: true\n    });\n  }\n\n  createNewProof() {\n    this.setState({ popupOpen: true })\n  }\n\n  render() {\n    if (this.state.canvasOpen) {\n      return (\n        <div className=\"App\">\n          <Canvas \n            saveProof={this.saveProof} \n            proof={this.state.proof} />\n        </div>\n      );\n    }\n    return (\n      <div className={this.state.initialCSS}>\n        <IntroWindow \n          ref={this.introWindow} \n          setupFunc={this.setupProof}/>\n      </div>\n    );\n  }\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.scss';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}