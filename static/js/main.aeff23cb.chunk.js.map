{"version":3,"sources":["verifySentence.js","converters.js","canvas/Toolbox.js","canvas/StepMenu.js","canvas/config.js","canvas/EGVariable.js","canvas/EGCut.js","canvas/DropdownMenu.js","canvas/manipulate.js","canvas/Canvas.js","intro/CreateNew.js","intro/IntroWindow.js","App.js","serviceWorker.js","index.js"],"names":["require","binary","unary","arrToRegex","arr","map","el","replace","join","uReg","Object","keys","regexStr","binaryRegex","RegExp","atomicRegex","parenthesisRegex","sentence","verifyRecursive","res","match","exec","operators","escapeRegExp","string","binarySymbReplace","unaryOperators","convertToTeX","formula","String","symbol","substr","length","i","countUnary","statement","matchesList","val","op","c","split","some","charAt","stripUnary","s","convertStatement","console","log","convertToEG","repeat","verifySentence","parenthesis","left","right","eg","getMatchingParen","start","parens","j","Toolbox","props","state","selected","functions","str","func","this","hidden","modifyCanvas","cancelSelection","Fragment","className","ref","canvas","style","backgroundColor","onClick","setState","React","Component","StepMenu","performRedo","bind","performUndo","event","step","disabled","preventDefault","setStep","evt","changeHistory","steps","redoHistory","prev","pop","push","prevSteps","st","obj","concat","hide","currentStep","stepInfo","backEnabled","forwardEnabled","color","getColor","handleClick","src","process","disable","gridSize","cutPadding","horizontal","vertical","cutCornerRadius","initialSeparation","EGVariable","text","createRef","getCoords","x","y","cursorOver","dragging","panzoom","window","addEventListener","onMouseMove","handleDragStart","handleDragEnd","enableHighlight","selectedCallback","id","current","cursor","pause","resume","setCoords","clientX","clientY","Math","round","config","removeEventListener","highlight","pointerEvents","interaction","fill","onMouseEnter","onMouseLeave","children","EGCut","cut","BB","getBBoxData","update","bounding","_x","_y","_w","_h","getBBox","width","height","interval","setInterval","setTimeout","clearInterval","fillOpacity","strokeOpacity","stroke","e","rx","toString","ry","DropdownMenu","menuItems","title","nanoid","getSelection","getInsertionPoint","requestInput","insertion","a","pt","input","iteration","copyID","insertData","insertID","data","copyStep","levelOffset","isInNestedGraph","findParent","copy","copyContents","findID","insert","newCopyID","changeCutLevel","level","offsetPosition","erasure","erased","parent","index","indexOf","splice","doubleCutEnclose","inside","cut1_id","cut2_id","cut1","type","doubleCutAdd","empty_id","var","doubleCutRemove","firstCut","secondCut","newContents","childID","parentID","parentStep","copyDataMap","newMap","m","copyDataArray","newArr","newStep","change","idFound","changeLevelArray","changeLevelMap","mapID","oldStep","oldData","newData","d","h","w","searchedStep","findInArray","findInMap","findIDArray","findIDMap","Array","Canvas","canvasContainer","renderStep","changePos","getSVGCoords","highlightCut","createElement","clickedCanvas","proof","premises","conclusion","moveListeners","highlights","cbFunction","finishCB","manipulate","fitchNotation","getCanvasInsertion","Promise","resolve","reject","canvasCb","all","selectConfig","nameOfFunction","finishedCb","slice","from","then","assign","odd","stepIndex","setXY","renderRecurse","jsx","groupElement","key","unshift","highlightVar","Panzoom","maxZoom","minZoom","vw","max","document","documentElement","clientWidth","innerWidth","vh","clientHeight","innerHeight","currentX","maxX","maxY","stepZero","initXYRecurse","gapSize","X","initXY","convertToArray","subExp","moveTo","zoomTo","domX","domY","createSVGPoint","matrixTransform","getScreenCTM","inverse","pageX","pageY","showOverlay","saveProof","zoomWithWheel","tex","transitionName","transitionAppear","transitionAppearTimeout","transitionEnter","transitionLeaveTimeout","name","onChange","for","target","value","math","onWheel","newSteps","CreateNew","handleChange","removePremise","verify","create","filename","setupFunc","closeBtn","formulaInput","getFormulaCell","IntroContent","recentDocs","display","justifyContent","open","delete","IntroWindow","createView","callCreate","animateAway","openFile","createShown","floatingWindowCSS","setAttribute","onchange","stopPropagation","file","files","reader","FileReader","JSON","parse","result","error","alert","readAsText","click","localStorage","App","createNewProof","setupProof","openCanvas","getRecents","introWindow","initialCSS","canvasOpen","popupOpen","element","Blob","stringify","href","URL","createObjectURL","download","body","appendChild","recents","getItem","rArray","setItem","Boolean","location","hostname","ReactDOM","render","getElementById","navigator","serviceWorker","ready","registration","unregister","catch","message"],"mappings":"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","file":"static/js/main.aeff23cb.chunk.js","sourcesContent":["/* \n * Return a boolean indicating if the inputted sentence is \n * a correctly formatted. Utilizes a recursive technique,\n * evaluating each sentence as though it were an atomic\n * sentence or any phi and psi combined with a binary \n * operator. \n*/\n\nconst { binary, unary } = require('./operators.json')\n\nfunction escapeRegExp(string) {\n  return string.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&'); // $& means the whole matched string\n}\n\nfunction arrToRegex(arr) {\n  arr = arr.map(el => escapeRegExp(el));\n  return '(?:' + arr.join('|') + ')'\n} \n\nconst uReg = arrToRegex(Object.keys(unary));\nconst regexStr = `^(${uReg}*[A-Za-z]+|${uReg}*\\\\((.*)\\\\))(${arrToRegex(Object.keys(binary))})(${uReg}*[A-Za-z]+|${uReg}*\\\\((.*)\\\\))$`\nlet binaryRegex = new RegExp(regexStr) // eslint-disable-line\nlet atomicRegex = new RegExp(`^${uReg}*[A-Za-z]+$`)\nlet parenthesisRegex = new RegExp(`^${uReg}*\\\\((.*)\\\\)$`)\n\nfunction verifyRecursive(sentence) {\n  let res\n  if (sentence.match(atomicRegex)) return true;\n  else if ((res = binaryRegex.exec(sentence)) !== null) {\n    if (res == null) return false;\n    if (res[2] && res[5]) \n      return verifyRecursive(res[2]) && verifyRecursive(res[5]);\n    else if (res[2]) \n      return verifyRecursive(res[2]);\n    else if (res[5]) \n      return verifyRecursive(res[5]);\n    else return true;\n  } else if ((res = parenthesisRegex.exec(sentence)) !== null)\n    return verifyRecursive(res[1])\n}\n\nexport {\n  binaryRegex,\n  atomicRegex,\n  parenthesisRegex\n}\n\nexport default (sentence) => {\n  // filter out spaces\n  sentence = sentence.replace(/\\s/g, '')\n  return verifyRecursive(sentence);\n}","import verifySentence, { \n  parenthesisRegex, \n  binaryRegex,\n  atomicRegex\n} from './verifySentence';\n\nconst operators = require('./operators.json')\n\n/**\n * This file is responsible for holding many of the converters used throughout the \n * app.\n */\n\n/**\n * @param  {string} the string to add escape characters for\n * @return {string} the string with all regex-safe characters\n */\nfunction escapeRegExp(string) {\n  return string.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&'); // $& means the whole matched string\n}\n\n/**\n * keys represents the ASCII notation for the input characters. \n * @type {array}\n */\nlet keys = Object.keys(operators.binary);\nkeys = keys.map(el => escapeRegExp(el));\nconst binarySymbReplace = new RegExp('(?:' + keys.join('|') + ')', 'g')\nconst unaryOperators = operators.unary\n\n/**\n * @param  {string} Fitch-style sentence notation.\n * @return {string} TeX sentence notation.\n */\nconst convertToTeX = (formula) => {\n  if (typeof formula === 'string' || formula instanceof String) {\n    // filter out spaces\n    formula = formula.replace(/\\s/g, '')\n    let symbol\n    // replace all binary operators\n    while ((symbol = binarySymbReplace.exec(formula)) !== null) {\n      formula = formula.substr(0,symbol['index']) \n                    + operators.binary[symbol[0]] + ' '\n                    + formula.substr(symbol['index'] + symbol[0].length);\n    }\n    // replace all unary operators\n    for (let i in Object.keys(unaryOperators)) {\n      symbol = Object.keys(unaryOperators)[i];\n      formula = formula.replace(new RegExp(escapeRegExp(symbol), 'g'), unaryOperators[symbol] + ' ');\n    }\n    // filter out all other characters\n    formula = formula.replace(/[^()A-Za-z\\\\\\s]/g, '')\n    return formula\n  }\n  else return \"\"\n}\n\n/**\n * @param  {string} statement\n * @return {int} counts the number of unary operators in the given input.\n *\n * For example, if passed a statement !!(P | Q), we notice two unary operators \n * encapsulating the statement (the ! symbols, representing NOT). These would \n * be counted out.\n */\nfunction countUnary(statement) {\n  const matchesList = (val) => (op) => op === val;\n  let c = 0;\n  for (c in statement.split(\"\"))\n    if (!Object.keys(unaryOperators).some(matchesList(statement.charAt(c))))\n      break;\n  return c;\n}\n\n/**\n * @param  {string} the sentence being passed in, in Fitch-style notation.\n * @param  {bool} whether to convert the statement to EG or just return without unary.\n * @return {[type]}\n */\nconst stripUnary = (s, convertStatement) => {\n\n  console.log(s)\n  console.log(convertStatement)\n  if (convertStatement == null) \n    convertStatement = true;\n  let c = countUnary(s);\n  let statement = s.substr(c)\n  if (convertStatement) statement = convertToEG(statement)\n  else statement = '{' + statement + '}'\n  return \"(\".repeat(c) + statement + \")\".repeat(c)\n}\n\n/**\n * @param  {string} Fitch-style sentence notation \n * @return {string} EG-style sentence notation.\n */\nconst convertToEG = (formula) => {\n  if ((typeof formula === 'string' || formula instanceof String) && verifySentence(formula)) {\n    // filter out spaces\n    formula = formula.replace(/\\s/g, '')\n    let binary = binaryRegex.exec(formula)\n    let parenthesis = parenthesisRegex.exec(formula)\n    let unary = atomicRegex.exec(formula)\n    if (binary) {\n      let left = convertToEG(binary[1])\n      let right = convertToEG(binary[4])\n      let symConversion = operators.eg[binary[3]];\n      return symConversion.replace(/\\$1/g, left).replace(/\\$2/g, right)\n    } else if (parenthesis) {\n      if (countUnary(formula) !== 0) {\n        return stripUnary(formula.substr(1,formula.length-2), true);\n      }\n      return convertToEG(parenthesis[1]);\n    } else if (unary) {\n      return stripUnary(formula, false);\n    } else return null;\n  }\n  else return null;\n}\n\n/** \n * Given a string and the index of the open parenthesis, this\n * will return the index of the closed parenthesis\n */\nconst getMatchingParen = (formula, start) => {\n  // hold the number of '(' minus the number of ')'\n  let parens = 0\n  let j = start\n  while (j < formula.length) {\n    if (formula[j] === '(') {\n      parens++\n    }\n    else if (formula[j] === ')') {\n      parens--\n      // if parens is 0, then the current ')' matches the start parenthesis\n      if (parens === 0)\n        return j\n    }\n    j++\n  }\n}\n\n/**  \n * Converts a string representing an Existential Graph into\n * a nested array. Acts recursively, calling iteslf again\n * When a pair of parentehses are found. If given an index i,\n * this will start from that index.\n * \n * For example: \n * \"((({P})){Q}{R}){P}\" => [ [ [['P']],'Q','R' ],'P' ]\n */\nconst convertToArray = (formula, i = 0) => {\n  if (typeof formula === 'string' || formula instanceof String) {\n    // hold the array of the current level that will be returned\n    let arr = []\n    // loop through the string\n    while (i < formula.length) {\n      // if closing parenthesis, return the array for this subexpression\n      if (formula[i] === '(') {\n        // find the matching pair of parentheses of the subexpression\n        let j = getMatchingParen(formula, i)\n        // push the subexpression into the array\n        let subExp = formula.substr(i+1, j-1)\n        if (subExp)\n          arr.push(convertToArray(formula.substr(i+1, j-1)))\n        i = j\n      }\n      // if a variable is found, push it to the array\n      else if (formula[i] === '{') {\n        let text = formula[++i];\n        if (text === '}') arr.push('\\u00A0')\n        else arr.push(text)\n        i++\n      }\n      i++\n    }\n    // return the array that values the current expression\n    return arr\n  }\n  else return null\n}\n\n/**\n * Export all converters\n */\nexport {\n  convertToTeX,\n  convertToEG,\n  convertToArray,\n  verifySentence\n}","import React from 'react';\n\nclass Toolbox extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      selected: null,\n      functions: [\n        {\n          str: \"Iterate\",\n          func: 'iteration',\n        },\n        {\n          str: \"Wrap in Double Cut\",\n          func: 'doubleCutEnclose',\n        },\n        {\n          str: \"Add Double Cut\",\n          func: 'doubleCutAdd',\n        },\n        {\n          str: \"Remove Double Cut\",\n          func: 'doubleCutRemove',\n        },\n        {\n          str: \"Insertion\",\n          func: 'insertion',\n        },\n        {\n          str: \"Erasure\",\n          func: 'erasure',\n        }\n      ]\n    };\n  }\n\n  componentDidMount() {  \n  }\n\n  render() {\n    let { hidden, modifyCanvas, cancelSelection } = this.props;\n    let { selected } = this.state;\n    if (hidden) return <React.Fragment />;\n    return (\n      <div className=\"toolbox\" ref={this.canvas}>\n        <h3>Tools</h3>\n        {this.state.functions.map((el, i) => (\n          <div \n            className=\"tool\"\n            style={selected === i ? { backgroundColor: '#AFAFAA' } : {}} \n            onClick={() => {\n              if (this.state.selected === i) {\n                cancelSelection();\n              }\n              else {\n                this.setState({ selected: i });\n                modifyCanvas(el.func, () => {\n                  this.setState({ selected: null });\n                });\n              }\n            }\n          }\n          >{el.str}</div>\n        ))}\n      </div>\n    );\n  }\n}\n\nexport default Toolbox;","import React from 'react';\nimport { ReactSVG } from 'react-svg';\n\nclass StepMenu extends React.Component {\n  constructor(props) {\n    super(props);\n  \n    this.performRedo = this.performRedo.bind(this);\n    this.performUndo = this.performUndo.bind(this);\n    this.state = {};\n  }\n  handleClick(event, step, disabled) {\n    event.preventDefault();\n    if (!disabled) {\n      // Must update color before updating props to allow component to\n      // render with the proper current color rather than the state before\n      this.props.setStep(step);\n    }\n  }\n\n  performUndo(evt) {\n    let { changeHistory, steps, redoHistory } = this.props.state;\n    let prev = changeHistory.pop();\n\n    if (prev) {\n      redoHistory.push(steps);\n      this.props.setState(changeHistory, prev.steps, redoHistory);\n    }\n  }\n\n  performRedo(evt) {\n    let { changeHistory, steps, redoHistory } = this.props.state;\n    let prevSteps = redoHistory.pop();\n\n    if (prevSteps) {\n      changeHistory.push({ redoHistory, steps });\n      this.props.setState(changeHistory, prevSteps, redoHistory);\n    }\n  }\n\n  getColor(disabled) {\n    return disabled ? \"rgb(136, 136, 136)\" : \"rgb(68, 68, 68)\";\n  }\n\n  disable(st, obj) {\n    return st.concat(obj.length > 0 ? \"\" : \" disabled\")\n  }\n\n  render() {\n    let { hide, currentStep, stepInfo, state } = this.props;\n    let { changeHistory, redoHistory } = state;\n    if (hide) return (<React.Fragment />);\n    let backEnabled = currentStep === (stepInfo.length - 1);\n    let forwardEnabled = currentStep === 0;\n    return (\n      <React.Fragment>\n        <div className=\"step-menu\">\n        <div style={{ color: this.getColor(forwardEnabled)}}>\n          <div onClick={(event) => this.handleClick(event, 0, forwardEnabled)}>\n            <ReactSVG src={process.env.PUBLIC_URL + \"/assets/step-first.svg\"}/>\n          </div>\n          <div onClick={(event) => this.handleClick(event, currentStep - 1, forwardEnabled)}>\n            <ReactSVG src={process.env.PUBLIC_URL + \"/assets/step-prev.svg\"} />\n          </div>\n        </div>\n        <div>\n          <div className={this.disable(\"undo-btn\", changeHistory)} onClick={this.performUndo}>\n            <div className=\"undo-svg\">\n              <ReactSVG src={process.env.PUBLIC_URL + \"/assets/undo.svg\"} />\n            </div>\n          </div>\n          <div className={this.disable(\"redo-btn\", redoHistory)} onClick={this.performRedo}>\n            <div className=\"redo-svg\">\n              <ReactSVG src={process.env.PUBLIC_URL + \"/assets/redo.svg\"} />\n            </div>\n          </div>\n          \n        </div>\n        <div style={{ color: this.getColor(backEnabled)  }}>\n          <div onClick={(event) => this.handleClick(event, currentStep + 1, backEnabled)}>\n            <ReactSVG src={process.env.PUBLIC_URL + \"/assets/step-next.svg\"} />\n          </div>\n          <div onClick={(event) => this.handleClick(event, stepInfo.length - 1, backEnabled)}>\n            <ReactSVG src={process.env.PUBLIC_URL + \"/assets/step-last.svg\"} />\n          </div>\n        </div>\n        </div>\n        <div className=\"step-text\">\n          Step {currentStep + 1} of {stepInfo.length}\n        </div>\n      </React.Fragment>\n    );\n  }\n}\n\nexport default StepMenu;","export default {\n  gridSize: 1,\n  cutPadding: {\n    horizontal: 10,\n    vertical: 5\n  },\n  cutCornerRadius: 10,\n  initialSeparation: 50,\n}","import React from 'react';\nimport config from './config';\n\nclass EGVariable extends React.Component {\n  constructor(props) {\n    super(props);\n    this.text = React.createRef()\n    this.getCoords = this.props.getCoords\n    this.handleClick = this.handleClick.bind(this);\n    this.state = {\n      x: props.x,\n      y: props.y,\n      cursorOver: false,\n      dragging: false\n    };\n\n    this.panzoom = this.props.panzoom\n\n    window.addEventListener('mousemove', this.onMouseMove.bind(this))\n    window.addEventListener('mousedown', this.handleDragStart.bind(this))\n    window.addEventListener('mouseup', this.handleDragEnd.bind(this))\n    window.addEventListener('click', this.handleClick)\n  }\n\n  handleClick() {\n    if (this.state.cursorOver \n      && this.props.enableHighlight \n      && this.props.selectedCallback) \n    {\n      this.props.selectedCallback(this.props.id);\n      this.setState({ cursorOver: false });\n    }\n  }\n\n  componentDidMount() {  \n    this.text.current.style.cursor = \"pointer\";\n  }\n\n  handleDragStart(evt) {\n    if (this.state.cursorOver) {\n      this.panzoom.pause()\n      this.setState({ dragging: true })\n    }\n  }\n\n  handleDragEnd(evt) {\n    this.panzoom.resume()\n    let { x, y } = this.state;\n    this.props.setCoords(x, y);\n    this.setState({ dragging: false })\n  }\n\n  onMouseMove(evt) {\n    if (this.state.dragging) {\n      let { x, y } = this.getCoords(evt.clientX, evt.clientY)\n      x = Math.round(x/config.gridSize)*config.gridSize\n      y = Math.round(y/config.gridSize)*config.gridSize\n      this.props.setCoords(x, y);\n      this.setState({ x: x, y: y })\n    }\n  }\n\n  componentWillUnmount() {\n    window.removeEventListener('click', this.handleClick);\n    window.removeEventListener('mousemove', this.onMouseMove.bind(this))\n    window.removeEventListener('mousedown', this.handleDragStart.bind(this))\n    window.removeEventListener('mouseup', this.handleDragEnd.bind(this))\n  }\n\n  render() {\n    let highlight = this.state.cursorOver && this.props.enableHighlight;\n    return (\n      <text \n        className=\"noselect\"\n        pointerEvents={this.props.interaction ? null : 'none'}\n        x={this.state.x} \n        y={this.state.y} \n        id={this.props.id}\n        fill={highlight ? \"blue\" : \"black\"}\n        onMouseEnter={() => this.setState({ cursorOver: true })}\n        onMouseLeave={() => this.setState({ cursorOver: false })}\n        ref={this.text}>\n        {this.props.children}\n      </text>\n    );\n  }\n}\n\nexport default EGVariable;","import React from 'react';\nimport config from './config';\n\nclass EGCut extends React.Component {\n  constructor(props) {\n    super(props);\n    this.cut = React.createRef();\n    this.BB = React.createRef();\n    this.getBBoxData = this.getBBoxData.bind(this);\n    this.handleClick = this.handleClick.bind(this);\n    this.update = this.update.bind(this);\n    this.state = { highlight: false, bounding: {_x:0,_y:0,_w:0,_h:0} };\n\n    window.addEventListener('click', this.handleClick)\n  }\n\n  handleClick() {\n    if (this.state.highlight \n      && this.props.enableHighlight \n      && this.props.selectedCallback) \n    {\n      this.props.selectedCallback(this.props.id);\n      this.setState({ highlight: false });\n    }\n  }\n\n  getBBoxData() {\n    if (this.cut.current) {\n      let { x, y, width, height } = this.cut.current.getBBox();\n      let _x = x - config.cutPadding.horizontal;\n      let _y = y - config.cutPadding.vertical;\n      let _w = width + config.cutPadding.horizontal * 2;\n      let _h = height + config.cutPadding.vertical * 2;\n      return { _x, _y, _w, _h };\n    }\n    return {};\n  }\n\n  update() {\n    if (!this.interval) {\n      this.interval = setInterval(() => {\n        this.setState({ bounding: this.getBBoxData() });\n      }, 1);\n      setTimeout(() => {\n        clearInterval(this.interval);\n        this.interval = null;\n      }, 100);\n    }\n  }\n\n  componentDidMount() { \n    this.update()\n  }\n\n  componentDidUpdate() {\n    this.update()\n  }\n\n  componentWillUnmount() {\n    window.removeEventListener('click', this.handleClick);\n    if (this.interval)\n      clearInterval(this.interval);\n  }\n\n  render() {\n    let highlight = this.state.highlight && this.props.enableHighlight;\n    let { _x, _y, _w, _h } = this.state.bounding;\n    return (\n      <React.Fragment>\n        <rect\n          x={_x}\n          y={_y}\n          width={_w}\n          height={_h}\n          fillOpacity=\"0.7\" \n          strokeOpacity=\"1\"\n          stroke=\"black\"\n          fill={highlight ? \"#9AA899\" : \"white\"}\n          onMouseEnter={(e) => this.setState({ highlight: true })}\n          onMouseLeave={(e) => this.setState({ highlight: false })}\n          rx={config.cutCornerRadius.toString()} \n          ry={config.cutCornerRadius.toString()}\n        />\n        <g ref={this.cut}>\n          {this.props.children}\n        </g>\n      </React.Fragment>\n    );\n  }\n}\n\nexport default EGCut;","import React from 'react';\n\nclass DropdownMenu extends React.Component {\n  render() {\n    const menuItems = this.props.menuItems;\n    return (\n      <div className=\"dropdown-menu\">\n        {menuItems.map(el => {\n            if (el.title) return <div className=\"menu-title\" onClick={el.func}>{el.title}</div>;\n            else return <div className={el} />\n          }\n        )}\n      </div>\n    );\n  }\n}\n\nexport default DropdownMenu;","const nanoid = require('nanoid').nanoid;\n\nexport default ({ state, getSelection, getInsertionPoint, requestInput }) => { \n  return {\n    state: state,\n\n    insertion: async function () {\n      let pt = await getInsertionPoint();\n      console.log(pt)\n      if (!pt) return null;\n      let { id, x, y } = pt;\n      let input = await requestInput();\n      if (!input) return null;\n\n      console.log(id, x, y)\n      console.log(input)\n\n      // await getSelection({ 'cut': 'odd', 'var': 'odd' });\n      // let id = nanoid()\n      // state.data[id] = { \n      //   type: \"var\",\n      //   var: state.step[s], \n      //   x: 0, \n      //   y: 0,\n      //   level: level\n      // }\n      return state;\n    },\n\n    /* Given a copyID and insertID, the iteration function creates a new step,\n     * and adds a copy of the data represented by copyID at the location of insertID\n     * only if the location of insertID is a child of copyID\n     */\n    iteration: async function () {\n      let copyID = await getSelection({ 'cut': 'all', 'var': 'all' });\n      if (!copyID) return null;\n      let insertData = await getInsertionPoint();\n      if (!insertData) return null;\n      let { id, x, y } = insertData;\n      let insertID = id;\n      if (!insertID) return null;\n      let { steps, currentStep, data } = this.state;\n      let step = this.copyStep(steps[currentStep]);\n      // If the insertID data is not in a subgraph of the copyID data, return\n      let levelOffset = 1;\n      if (!this.isInNestedGraph(step, insertID, copyID)) {\n        if (insertID === this.findParent(step, copyID).id) {\n          levelOffset = 0;\n        } else {\n          console.log(\"Insert selection is not in a subgraph of Copy selection\");\n          return null;\n        }\n      }\n      // use findID to find the data represented by the two IDs\n      let copy = this.copyContents(this.findID(step, copyID));\n      console.log(copy)\n      if (!copy) {\n        console.log(\"Copy ID could not be found in Iterate\");\n        return null;\n      }\n      let insert = this.findID(step, insertID);\n      if (!insert.data) {\n        console.log(\"Insert ID could not be found in Iterate\");\n        return null;\n      }\n      insert.data = insert.data.concat(copy);\n      let newCopyID = copy;\n      if (typeof copy !== 'string')\n        newCopyID = copy.id\n      // Change the levels of the copy data\n      this.changeCutLevel(step, newCopyID, data[insert.id].level + levelOffset)\n      // Update the state\n      currentStep += 1;\n      steps.push(step);\n      return { steps: steps, currentStep: currentStep, data: this.offsetPosition(data, step, copy.id) };\n    },\n\n    erasure: async function () {\n      let id = await getSelection({ 'cut': 'even', 'var': 'even' });\n      if (id==null) return this.state;\n      let { steps, currentStep, data } = this.state;\n      // Create a new step\n      let step = this.copyStep(steps[currentStep]);\n      // Find the data that will be erased\n      let erased = this.findID(step, id);\n      if (!erased) {\n        return null;\n      }\n      // Get the parent of the erased section\n      let parent = this.findParent(step, id)\n      if (!parent) {\n        return null;\n      }\n      // Remove the erased data from the parent's data array\n      const index = parent.data.indexOf(erased);\n      if (index > -1)\n        parent.data.splice(index, 1);\n      else {\n        return null;\n      }\n      // Update the state\n      currentStep += 1;\n      steps.push(step);\n      return { steps: steps, currentStep: currentStep, data: data };\n    },\n\n    /* Adds a double cut given the ID of the data that will be inside the cut.\n    *  Will only run if the current step is the last step.\n    */\n    doubleCutEnclose: async function () {\n      var id = await getSelection({ 'cut': 'all', 'var': 'all' });\n      let { steps, currentStep, data } = this.state;\n      // create a new step\n      let step = this.copyStep(steps[currentStep]);\n      // use findID to find the data represented by the id\n      // this is the data that will be inside the two new cuts\n      let inside = this.findID(step, id);\n      if (!inside) {\n        return null;\n      }\n      // create a new cut with another one inside it\n      let cut1_id = nanoid();\n      let cut2_id = nanoid();\n      let cut2 = {\n        data: [inside],\n        id: cut2_id,\n        type: \"cut\"\n      }\n      let cut1 = {\n        data: [cut2],\n        id: cut1_id,\n        type: \"cut\"\n      }\n      // Set the levels of the two cuts\n      let level = data[id].level\n      data[cut2_id] = { type: \"cut\", level: level + 1};\n      data[cut1_id] = { type: \"cut\", level: level};\n      // increase the level of the inside cut along with all cuts inside of it by 2\n      this.changeCutLevel(step, id, 2)\n\n      // get the parent of the selection\n      let parent = this.findParent(step, id)\n      if (!parent) {\n        return null;\n      }\n      // Add the contents of the new cuts to the data array\n      // after removing the original contents\n      const index = parent.data.indexOf(inside);\n      if (index > -1) {\n        parent.data.splice(index, 1);\n      }\n      parent.data = parent.data.concat(cut1);\n      // Change the state data accordingly\n      currentStep+=1;\n      steps.push(step);\n      return { steps: steps, currentStep: currentStep, data:data };\n    },\n\n    /* Adds a double cut given the ID of the data that will be inside the cut.\n    *  Will only run if the current step is the last step.\n    */\n    doubleCutAdd: async function () {\n      let { id, x, y } = await getInsertionPoint();\n      if (!x || !y) return null;\n      let { steps, currentStep, data } = this.state;\n      // create a new step\n      let step = this.copyStep(steps[currentStep]);\n      // create a new cut with another one inside it\n      let cut1_id = nanoid();\n      let cut2_id = nanoid();\n      let empty_id = nanoid();\n      let cut2 = {\n        data: [empty_id],\n        id: cut2_id,\n        type: \"cut\"\n      }\n      let cut1 = {\n        data: [cut2],\n        id: cut1_id,\n        type: \"cut\"\n      }\n      // Set the levels of the two cuts\n      let level = id ? data[id].level : -1;\n      data[cut2_id] = { type: \"cut\", level: level + 2 };\n      data[cut1_id] = { type: \"cut\", level: level + 1 };\n      data[empty_id] = {\n        x, y,\n        type: \"emptyvar\", \n        var: \"\\xa0\",\n        level: level + 3 \n      };\n\n      // get the parent of the selection\n      if (id) {\n        let stepEl = this.findID(step, id);\n        // append new cuts\n        stepEl.data.push(cut1);\n      }\n      else {\n        step.data.push(cut1);\n      }\n      \n      // Change the state data accordingly\n      currentStep += 1;\n      steps.push(step);\n      return { steps: steps, currentStep: currentStep, data: data };\n    },\n\n    /* Removes a double cut given the ID of the outside cut.\n    *  Will only run if the current step is the last step.\n    *  Creates a deep copy of the current step, and replaces the cut with\n    *  the given ID with the contents of the second cut, only if they exist.\n    *  Then adds the edited copy of the current step to the end of the step array.\n    */\n    doubleCutRemove: async function () {\n      let id = await getSelection({ 'cut': 'all' });\n      let { steps, currentStep, data } = this.state;\n      // Create a new step\n      let step = this.copyStep(steps[currentStep]);\n\n      // use findID to find the cut with the given ID\n      let firstCut = this.findID(step, id);\n      // If it is actually a cut and has another cut inside\n      if (firstCut && firstCut.type === \"cut\") {\n        let secondCut = firstCut.data;\n        if (secondCut && secondCut.length === 1 && secondCut[0].type === \"cut\") {\n          // Get the data inside the second cut\n          let newContents = secondCut[0].data;\n          // Get the parent of the original cut being removed\n          let parent = this.findParent(step, id)\n          if (!parent) {\n            return null;\n          }\n          this.changeCutLevel(step, secondCut[0].id, -2)\n          // Remove the first cut from the data array\n          const index = parent.data.indexOf(firstCut);\n          if (index > -1) {\n            parent.data.splice(index, 1);\n          }\n          // Add the contents of the second cut to the data array\n          parent.data = parent.data.concat(newContents);\n          // Update the state\n          currentStep+=1;\n          steps.push(step);\n          return { steps: steps, currentStep: currentStep, data:data };\n        }\n        else return null;\n      }\n      else return null;\n    },\n\n\n    /* Given a step and two IDs, will return true if the data of ChildID is\n     * in a nested graph of parentID in the current step.\n     */\n    isInNestedGraph: function (step, childID, parentID) {\n      let parentStep = this.findParent(step, parentID);\n      if (!parentStep) {\n        console.log(\"Parent Data could not be found\");\n        return false;\n      }\n      let childStep = this.findID(parentStep, childID);\n      if (!childStep) {\n        console.log(\"Child is not in nested graph of Parent\");\n        return false;\n      }\n      return true;\n    },\n\n    /* Given a step or a cut, will copy the contents inside with new IDs\n     * and return the new data. This permits inserting new data into the graph.\n     * Levels for cuts will start at 0 and increase accordingly\n     */\n    copyContents: function (step) {\n      let { data } = this.state;\n      // Copies the data of a map and returns it\n      // Also updates the state.data map according to new generated IDs\n      function copyDataMap(map, level) {\n        // If a variable is passed it, add it to the data and return the new ID\n        if (typeof map === 'string') {\n          let id = nanoid();\n          data[id] = {\n              type: \"var\",\n              var: data[map].var,\n              x: data[map].x,\n              y: data[map].y,\n              level: data[map].level\n          }\n          return id;\n        }\n        let newMap = {};\n        for (let m in map) {\n          // If an ID is found, generate a new one\n          if (m === 'id') {\n            let id = nanoid();\n            newMap[m] = id;\n            // Add the new data to state.data via a deep copy\n            data[id] = {\n              type: \"cut\",\n              level: level\n            }\n          }\n          // Otherwise, if not a data array, copy the contents\n          else if (m !== 'data'){\n            newMap[m] = map[m]\n          }\n          // If a data array, copy using helper function\n          else {\n            newMap[m] = copyDataArray(map[m], level+1)\n          }\n        }\n        return newMap;\n      }\n      // Copies the data of an array and returns it\n      // Also updates state.data according to new generated IDs\n      function copyDataArray(arr, level) {\n        let newArr = [];\n        for (let a in arr) {\n          // If an ID found, generate a new one\n          if (typeof arr[a] === 'string') {\n            let id = nanoid();\n            newArr.push(id);\n            // Add the new data to state.data via a deep copy\n            data[id] = {\n              type: \"var\",\n              var: data[arr[a]].var,\n              x: data[arr[a]].x,\n              y: data[arr[a]].y,\n              level: data[arr[a]].level\n            }\n          }\n          // otherwise, call the other helper function to copy contents\n          else {\n            newArr.push(copyDataMap(arr[a], level))\n          }\n        }\n        return newArr;\n      }\n      let newStep = copyDataMap(step, 0);\n      this.state.data = data;\n      return newStep;\n    },\n\n    /* Given a step and the ID of a cut, will iterate through all cuts within\n     * that cut and change their level by a specified amount.\n    */\n    changeCutLevel: function (step, id, change) {\n      let { data } = this.state\n      // If the ID is for a variable, only increase it's level\n      if (data[id] && data[id].type === \"var\") {\n        data[id].level += change;\n        return\n      }\n      // when true, the levels should change in the functions below\n      let idFound = false\n      // Changes the \n      function changeLevelMap(map) {\n        // get the id for the current map\n        let mapID;\n        if (map.id) {\n          mapID = map.id\n          // if it matches the id being searched, update the boolean\n          if (mapID === id) {\n            idFound = true;\n          }\n        }\n        // If the ID has been found, update the level of the current cut\n        if (idFound) {\n          data[mapID].level += change;\n        }\n        // call the function of the data array if it exists\n        if (map.data){\n          changeLevelArray(map.data);\n        }\n      }\n      function changeLevelArray(arr) {\n        for (let a in arr) {\n          // If a non-string is found (a cut)\n          if (typeof arr[a] !== 'string') {\n            // Change the level of the cut\n            changeLevelMap(arr[a])\n          }\n          // If string is found, change the level of the variable\n          else if (idFound){\n            data[arr[a]].level += change;\n          }\n        }\n      }\n      changeLevelArray(step.data)\n      this.state.data = data;\n    },\n\n    // Performs a deep copy of oldStep into newStep, used to not change previous steps\n    // By allowing them to be copied without using a reference\n    copyStep: function (oldStep) {\n      let newStep = {};\n      function copyDataMap(oldData) {\n        let newData = {};\n        for (let d in oldData) {\n          // If an id or type if found, copy directly\n          if(typeof oldData[d] === 'string') {\n            newData[d] = oldData[d];\n          }\n          // Otherwise if an array is found, copy using helper function\n          else {\n            newData[d] = copyDataArray(oldData[d]);\n          }\n        }\n        return newData;\n      }\n      function copyDataArray(oldData) {\n        let newData = [];\n        for (let d in oldData) {\n          // If an ID is found (variable), copy directly\n          if(typeof oldData[d] === 'string') {\n            newData.push(oldData[d]);\n          }\n          // If a map was found (cut), copy using helper function\n          else {\n            newData.push(copyDataMap(oldData[d]));\n          }\n        }\n        return newData;\n      }\n      // Copy the data, width, and height of the original into the new step\n      newStep.data = copyDataArray(oldStep.data);\n      newStep.h = oldStep.h;\n      newStep.w = oldStep.w;\n      return newStep;\n    },\n\n    /* Finds and returns the item that is the parent of the item\n     * with the specified ID, given the step to search as well.\n    */\n    findParent: function (searchedStep, id) {\n      // holds the parent of the id\n      let parent = searchedStep\n      // Searches an array for the ID, returns true if it is found\n      function findInArray(arr) {\n        for (let a in arr) {\n          // If an ID is found, compare it\n          if (typeof arr[a] === 'string') {\n            if (arr[a] === id) {\n              return true;\n            }\n          }\n          // Otherwise if a datamap is found, check the ID\n          else {\n            // If ID matches, return true\n            if (arr[a].id && arr[a].id === id) {\n              return true;\n            }\n            // Otherwise, search the datamap\n            else {\n              findInMap(arr[a])\n            }\n          }\n        }\n        return false;\n      }\n      function findInMap(map) {\n        // if the map contains data, search the data\n        if (map.data) {\n          // if found, set parent to this map\n          if(findInArray(map.data)) {\n            parent = map;\n          }\n        }\n      }\n      findInArray(searchedStep.data);\n      return parent;\n    },\n\n    // finds and returns the item with the specified ID in a given step\n    findID: function (searchedStep, id) {\n      // Find the ID in an array\n      function findIDArray(arr) {\n        for (let a in arr) {\n          // if a string, aka an ID\n          if (typeof arr[a] === 'string') {\n            // return the ID if found\n            if (arr[a] === id) {\n              return id;\n            }\n          }\n          // if a data map is found with the correct id, return the data map\n          else if (arr[a].id === id) {\n            return arr[a];\n          // otherwise, call findID step on the datamap that has the incorrect ID\n          } else {\n            let s = findIDMap(arr[a]);\n            if (s)\n              return s;\n          }\n        }\n      }\n      // Finds the ID in a data map representing a step\n      function findIDMap(step) {\n        if (typeof step === 'string') {\n          if (step === id)\n            return step;\n          else\n            return\n        }\n        for (let s in step) {\n          // if an array is found, call findIDArray on each element\n          if (step[s] instanceof Array) {\n            return findIDArray(step[s]);\n          // if an id is found, check if it matches and return the data if so\n          } else if (s === \"id\") {\n            if (step[s] === id)\n              return step;\n          }\n        }\n      }\n      return findIDMap(searchedStep);\n    },\n\n    /**\n     * Provided a data array, adds an x,y offset to the elements contained\n     * inside the provided id for visual differentiation\n     * @return {data} Data object\n     */\n    offsetPosition: function(data, step, id) {\n      let toSearch = this.findID(step, id);\n      console.log(data)\n      return data;\n    }\n  };\n}","import React from 'react';\nimport { convertToArray, convertToTeX, convertToEG } from '../converters';\nimport Toolbox from './Toolbox';\nimport StepMenu from './StepMenu';\nimport EGVariable from './EGVariable';\nimport EGCut from './EGCut';\nimport './Canvas.scss';\nimport Panzoom from 'panzoom';\nimport DropdownMenu from './DropdownMenu';\nimport config from './config';\nimport manipulate from './manipulate';\nimport { CSSTransitionGroup } from 'react-transition-group';\n// KATEX\nimport 'katex/dist/katex.min.css';\nimport TeX from '@matejmazur/react-katex';\n\nconst nanoid = require('nanoid').nanoid;\n\n/**\n * Where a lot of the action happens. This component renders the Canvas for \n * the Existential Graphs workspace. Meant to take up an entire page.\n */\n\n// some defaults: \n//    <text> blocks are automatically 22px high\n\nconst TEXT_H = 22;\n\nfunction initXY(step, level) {\n  let data = {}\n  let currentX = 0\n  let currentY = 0\n  let maxX = 0\n  let maxY = 0\n\n  // gapSize should be equal to the number of level changes\n  // in between two variables, so that we can evenly place \n  // them initially across the screen\n  function initXYRecurse(step, level, gapSize) {\n    for (let s in step) {\n      if (step[s] instanceof Array && step[s].length > 0) {\n        let id = nanoid()\n        step[s] = { data: initXYRecurse(step[s], level + 1), id: id, type: \"cut\" }\n        data[id] = { type: \"cut\", level: level }\n      } else {\n        let X = currentX;\n        let Y = currentY;\n        let id = nanoid()\n        data[id] = { \n          type: \"var\",\n          var: step[s], \n          x: Math.round(X/config.gridSize)*config.gridSize, \n          y: Math.round(Y/config.gridSize)*config.gridSize,\n          level: level\n        }\n        step[s] = id\n        maxY = Y > maxY ? Y : maxY;\n        maxX = X > maxX ? X : maxX;\n        currentX += config.initialSeparation\n      }\n    }\n    return step\n  }\n  return { stepZero: { data: initXYRecurse(step, level), h: maxY + TEXT_H, w: maxX }, data: data }\n}\n\nclass Canvas extends React.Component {\n  constructor(props) {\n    super(props);\n    this.canvas = React.createRef();\n    this.canvasContainer = React.createRef();\n\n    this.renderStep = this.renderStep.bind(this);\n    this.changePos = this.changePos.bind(this);\n    this.getSVGCoords = this.getSVGCoords.bind(this);\n    this.highlightCut = this.highlightCut.bind(this);\n    this.modifyCanvas = this.modifyCanvas.bind(this);\n    this.getInsertionPoint = this.getInsertionPoint.bind(this);\n    this.requestInput = this.requestInput.bind(this);\n    this.cancelSelection = this.cancelSelection.bind(this);\n    this.createElement = this.createElement.bind(this);\n    this.clickedCanvas = this.clickedCanvas.bind(this);\n\n    this.getSelection = this.getSelection.bind(this);\n\n    let { premises, conclusion, steps, data } = this.props.proof;\n    this.state = {\n      proof: {\n        premises: premises,\n        conclusion: conclusion\n      },\n      changeHistory: [], \n      redoHistory: [],\n      steps: steps || [],\n      data: data || {},\n      currentStep: steps.length !== 0 ? steps.length - 1 : 0,\n      moveListeners: [],\n      highlights: {\n        cut: 'none', // 'none', 'odd', 'even', 'all'\n        var: 'none',\n        canvas: false\n      },\n      cbFunction: null,\n      finishCB: null,\n      interaction: true,\n      functions: {\n        insertion: () => manipulate(this).insertion(),\n        erasure: () => manipulate(this).erasure(),\n        iteration: () => manipulate(this).iteration(),\n        doubleCutRemove: () => manipulate(this).doubleCutRemove(),\n        doubleCutEnclose: () => manipulate(this).doubleCutEnclose(),\n        doubleCutAdd: () => manipulate(this).doubleCutAdd(),\n      },\n      formula: '',\n      eg: '',\n      fitchNotation: false\n    }\n  }\n\n  /**\n   * Function to select a point on the canvas or inside a cut, where the x,y coordinate\n   * gets returned along with a cut ID, if selected.\n   */\n  getInsertionPoint() {\n    let getCanvasInsertion = new Promise((resolve, reject) => {\n      this.setState({\n        canvasCb: (x,y) => {\n          this.setState({ canvasCb: null })\n          \n          setTimeout(() => {\n            if (this.state.cbFunction) {\n              this.state.cbFunction(null);\n              this.setState({ cbFunction: null }, () => resolve({ x, y }));\n            } else resolve({ x, y });\n          }, 50);\n        }\n      })\n    });\n    return new Promise(async (resolve, reject) => {\n      let data = await Promise.all([this.getSelection({\n        'cut': 'all',\n        'var': 'none',\n        'canvas': true\n      }), getCanvasInsertion])\n      if (this.state.finishCB) {\n        this.state.finishCB();\n      }\n      this.setState({  \n        highlights: {\n          cut: 'none', \n          var: 'none',\n          canvas: false\n        },\n        finishCB: null,\n        canvasCb: null,\n        interaction: true, \n        cbFunction: null }, () => {\n          let [id, { x, y }] = data;\n          resolve({ id, x, y });\n        });\n    })\n  }\n\n  /**\n   * Function to enable selection of a cut or variable.\n   * @param  {Object} selectConfig  object that contains highlight selection params\n   *\n   * selectConfig object should look like { 'cut': 'all', 'var': 'all' }\n   * Omitted 'cut' or 'var' will result in either not allowing selection. Beyond 'all',\n   * 'even' or 'odd' level cuts can be specified.\n   */\n  getSelection(selectConfig) {\n    return new Promise((resolve, reject) => {\n      let { steps, currentStep } = this.state;\n      // only allow steps to be conducted at the end of a proof\n      if (currentStep+1 !== steps.length) {\n        return\n      }\n      this.setState({ \n        highlights: selectConfig, \n        interaction: false, \n        cbFunction: (id) => {\n          this.setState({  \n            highlights: {\n              cut: 'none', \n              var: 'none',\n              canvas: false\n            },\n            interaction: true, \n            cbFunction: null }, () => resolve(id));\n        }\n      });\n    });\n  }\n\n  modifyCanvas(nameOfFunction, finishedCb) {\n    // before we modify the canvas, let's save the current state\n    let { steps, changeHistory } = this.state;\n    changeHistory = changeHistory.slice()\n    changeHistory.push({ steps: Array.from(steps) });\n    // okay, now we call the requested function from Toolbox\n    this.setState({ finishCB: finishedCb }, () => {\n      this.state.functions[nameOfFunction]().then(state => {\n        if (this.state.finishCB) {\n          this.state.finishCB();\n        }\n        if (state) {\n          // now we can apply the new changeHistory\n          this.setState({ \n            changeHistory: changeHistory, \n            redoHistory: [],\n            ...state });\n        }\n      });\n    });\n  }\n\n  cancelSelection() {\n    let { cbFunction, canvasCb, finishCB } = this.state;\n    if (cbFunction) cbFunction();\n    if (canvasCb) canvasCb();\n    if (finishCB) finishCB();\n  }\n\n  changePos(id, x, y) {\n    let { data } = this.state;\n    Object.assign(data[id], { x: x, y: y })\n    this.setState(data)\n  }\n\n  highlightCut(level) {\n    if (this.state.highlights.cut === 'all') return true;\n    let odd = false;\n    if (level % 2 === 1) odd = true;\n    if (this.state.highlights.cut === 'odd' && odd) return true;\n    else if (this.state.highlights.cut === 'even' && !odd) return true;\n    return false;\n  }\n\n  highlightVar(level) {\n    if (this.state.highlights.var === 'all') return true;\n    let odd = false;\n    if (level % 2 === 1) odd = true;\n    if (this.state.highlights.var === 'odd' && odd) return true;\n    else if (this.state.highlights.var === 'even' && !odd) return true;\n    return false;\n  }\n\n  createElement(text, type, currentStep, x, y) {\n    let { data } = this.state;\n    let id = nanoid();\n    data[id] = {};\n    data[id].x = x || 0;\n    data[id].y = y || 0;\n    data[id].type = type;\n    data[id].var = text;\n    currentStep.push(id);\n    this.setState({ data });\n  }\n\n  removeElement(id) {\n    let { steps } = this.state;\n    steps[this.state.currentStep].push(id);\n  }\n\n  renderStep(stepIndex) {\n    let { data } = this.state;\n    let step = this.state.steps[stepIndex]\n    if (step) {\n      const setXY = (id,x,y) => {\n        data[id].x = x;\n        data[id].y = y;\n        this.setState({ data: data })\n      }\n\n      const renderRecurse = (step) => {\n        let jsx = [];\n        if (step.length === 0) {\n          this.createElement(\"\\xa0\", \"emptyvar\", step, 0, 0);\n        }\n        for (let s in step) {\n          if (step[s].type === \"cut\") {\n            let level = data[step[s].id].level;\n            let groupElement = (\n              <EGCut \n                level={level} \n                enableHighlight={this.highlightCut(level)}\n                id={step[s].id}\n                key={step[s].id}\n                selectedCallback={this.state.cbFunction}>\n                {renderRecurse(step[s].data)}\n              </EGCut>\n            );\n            jsx.push(groupElement);\n          } else if (this.state.data[step[s]].type === \"var\") {\n            let el = this.state.data[step[s]];\n            let level = data[step[s]].level;\n            jsx.unshift(\n              <EGVariable \n                x={el.x} \n                y={el.y} \n                id={step[s]} \n                enableHighlight={this.highlightVar(level)}\n                selectedCallback={this.state.cbFunction}\n                panzoom={this.panzoom}\n                interaction={this.state.interaction || this.highlightVar(level)}\n                getCoords={this.getSVGCoords}\n                setCoords={(x,y) => setXY(step[s],x,y)}\n                key={step[s]}>\n                {el.var}\n              </EGVariable>\n            );\n          } else if (this.state.data[step[s]].type === \"emptyvar\" && step.length === 1) {\n            let el = this.state.data[step[s]];\n            jsx.unshift(\n              <EGVariable \n                x={el.x} \n                y={el.y} \n                id={step[s]} \n                enableHighlight={false}\n                selectedCallback={() => {}}\n                panzoom={this.panzoom}\n                interaction={this.state.interaction}\n                getCoords={this.getSVGCoords}\n                setCoords={(x,y) => setXY(step[s],x,y)}\n                key={step[s]}>\n                {el.var}\n              </EGVariable>\n            );\n          }\n        }\n        return jsx;\n      }\n      renderRecurse.bind(this);\n      return renderRecurse(step.data)\n    }\n  }\n\n  componentDidMount() {  \n    this.panzoom = Panzoom(this.canvas.current, {\n      maxZoom: 6,\n      minZoom: 0.5\n    });\n    // this.canvasContainer.current.addEventListener('wheel', this.panzoom.zoomWithWheel);\n    const vw = Math.max(document.documentElement.clientWidth, window.innerWidth || 0);\n    const vh = Math.max(document.documentElement.clientHeight, window.innerHeight || 0);\n    // if there are no existing steps, init first step\n    let { steps } = this.state;\n    if (steps.length === 0) {\n      let { premises } = this.state.proof;\n      let { stepZero, data } = initXY(convertToArray(premises.join('')), 0);\n      steps.push(stepZero);\n      this.setState({ steps: steps, data: data });\n    }\n    // required to use setState to trigger re-render after creation of panzoom\n    this.setState({ });\n    let step = this.state.steps[this.state.currentStep];\n\n    // center the canvas elements\n    this.panzoom.moveTo(vw/2 - step.w, vh/2 - step.h);\n    this.panzoom.zoomTo(vw/2 - step.w, vh/2 - step.h, 2);\n  }\n\n  componentWillUnmount() {\n    window.removeEventListener('resize', this);\n  }\n\n  /**\n   * @param  {int} X on the DOM\n   * @param  {int} Y on the DOM\n   * @return {(int, int)} x,y pair representing point on Canvas\n   */\n  getSVGCoords(domX, domY) {\n    var pt = this.canvasContainer.current.createSVGPoint();\n    pt.x = domX;\n    pt.y = domY;\n    return pt.matrixTransform(this.canvas.current.getScreenCTM().inverse());\n  }\n\n  clickedCanvas(e) {\n    if (this.state.canvasCb) {\n      let { x, y } = this.getSVGCoords(e.pageX,e.pageY)\n      this.state.canvasCb(x,y);\n    }\n  }\n\n  requestInput() {\n    return new Promise((resolve, reject) => {\n      this.setState({ \n        showOverlay: true,\n        cbFunction: (formula) => {\n          if (formula == null) resolve(null);\n          else resolve(formula);\n          this.setState({ showOverlay: false });\n        } \n      });\n    });\n  }\n\n  render() {\n    let { proof, data, steps, currentStep, highlight, showOverlay } = this.state;\n    // every time a re-render happens, ensure top-level state is up-to-date\n    this.props.saveProof({...proof, data, steps});\n    // zooming function does nothing unless panzoom is initialized\n    let zoomWithWheel = () => {}\n    if (this.panzoom)\n      zoomWithWheel = this.panzoom.zoomWithWheel\n    // CSSTransitionGroup lets us have entry fade-in\n    let tex = convertToTeX(this.state.formula);\n    let eg = convertToEG(this.state.formula);\n    return (\n      <CSSTransitionGroup\n        transitionName=\"fadein\"\n        transitionAppear={true}\n        transitionAppearTimeout={500}\n        transitionEnter={false}\n        transitionLeaveTimeout={300}>\n        <div className={`insertOverlay${showOverlay ? ' shown' : ''}`}>\n          <h1>Formula to Insert</h1>\n          <input \n            name=\"notation\" \n            type=\"checkbox\" \n            className=\"check\" \n            onChange={ (e) => {\n              this.setState({ fitchNotation: !this.state.fitchNotation }); \n            }} />\n          <label for=\"notation\">&nbsp;Use Fitch-style notation</label><br />\n          {this.state.fitchNotation ? (\n              <div>\n                <table>\n                  <tbody>\n                    <tr>\n                      <td style={{ width: '40%' }}>\n                        <input onChange={ (e) => this.setState({ formula: e.target.value, eg }) } />\n                      </td>\n                      <td>\n                        {tex && <TeX math={tex} />}\n                      </td>\n                    </tr>\n                    <tr />\n                  </tbody>\n                </table>\n                To insert: {eg && <TeX math={eg} />}\n              </div>\n            ) : (\n              <div>\n                <input onChange={ (e) => this.setState({ formula: e.target.value, eg: e.target.value }) } /><br />\n                To insert: <TeX math={this.state.formula} />\n              </div>\n            )}\n          <span className='buttons'>\n            <button onClick={() => this.state.cbFunction(this.state.eg)}>Insert</button>\n            <button onClick={() => this.state.cbFunction(null)}>Cancel</button>\n          </span>\n        </div>\n        <div key={'main-div'} className={`mainCanvas noselect${showOverlay ? ' disabled' : ''}`}>\n          <DropdownMenu \n            menuItems={this.props.menuItems}/>\n          <Toolbox \n            hidden={currentStep+1 !== steps.length}\n            functions={this.state.functions}\n            modifyCanvas={this.modifyCanvas}\n            cancelSelection={this.cancelSelection}\n          />\n          <svg \n            ref={this.canvasContainer}\n            className=\"canvas noselect\" \n            onWheel={zoomWithWheel} \n            onClick={this.clickedCanvas}\n            onMouseEnter={() => this.setState({ highlight: true })}\n            onMouseLeave={() => this.setState({ highlight: false })}\n            style={this.state.canvasCb ? {\n              cursor: 'crosshair',\n              backgroundColor: highlight ? \"#BAC8B9\" : \"white\"\n            } : {}}>\n            <g ref={this.canvas}>\n              {this.panzoom && this.renderStep(this.state.currentStep)}\n            </g>\n          </svg>\n          <StepMenu \n            currentStep={this.state.currentStep} \n            stepInfo={this.state.steps} \n            setStep={s => this.setState({ currentStep: s, interaction: s === this.state.steps.length - 1 })}\n            state={this.state}\n            setState={(changeHistory, newSteps, redoHistory) => {\n              this.setState({ \n                changeHistory: changeHistory, \n                steps: newSteps, \n                redoHistory: redoHistory, \n                currentStep: newSteps.length - 1 \n              });\n            }}\n          />\n        </div>\n      </CSSTransitionGroup>\n    );\n  }\n}\n\nexport default Canvas;\n","import React from 'react';\nimport verify from '../verifySentence';\nimport { convertToTeX, convertToEG } from '../converters';\n// KATEX\nimport 'katex/dist/katex.min.css';\nimport TeX from '@matejmazur/react-katex';\nimport './CreateNew.scss';\n\nclass CreateNew extends React.Component {\n  constructor(props) {\n    super(props);\n  \n    this.state = {\n      premises: [\n        ''\n      ],\n      conclusion: ''\n    };\n\n    this.handleChange.bind(this)\n    this.removePremise.bind(this)\n    this.verify = this.verify.bind(this)\n    this.create = this.create.bind(this)\n    this.filename = React.createRef()\n  }\n\n  componentDidMount() {\n\n  }\n\n  handleChange(e, i) {\n    if (i != null) {\n      let { premises } = this.state;\n      premises[i] = e.target.value;\n      this.setState({ premises: premises })\n    }\n    else this.setState({ conclusion: e.target.value })\n  }\n\n  removePremise(index) {\n    let { premises } = this.state;\n    premises.splice(index, 1);\n    this.setState({ premises: premises })\n  }\n\n  verify() {\n    let { premises, conclusion } = this.state;\n    for (let i in premises) {\n      if (premises[i] === '' || !premises[i])\n        return false;\n    }\n    if (conclusion === '' || !conclusion)\n      return false;\n    return true;\n  }\n\n  create() {\n    console.log(\"Creating...\")\n    console.log(\"Verification concluded \" + this.verify())\n    if (this.verify()) {\n      let { premises, conclusion } = this.state;\n      for (let i in premises) {\n        premises[i] = convertToEG(premises[i])\n        console.log(premises[i])\n      }\n      conclusion = convertToEG(conclusion)\n      this.props.setupFunc(this.filename.current.value, { premises, conclusion, steps: [] })\n    }\n  }\n\n  getFormulaCell(formula, i) {\n    let tex, eg\n    if (verify(formula)) {\n      tex = convertToTeX(formula);\n      eg = convertToEG(formula);\n    }\n    let closeBtn = <td \n      className=\"close interactive\" \n      onClick={() => this.removePremise(i)}>\n        &#10005;\n      </td>;\n    let formulaInput = <input onChange={ (e) => this.handleChange(e,i) } />;\n    if (i == null) {\n      formulaInput = <input onChange={ (e) => this.handleChange(e) } />;\n      closeBtn = <td className=\"close\"/>;\n    }\n    if (i === 0) \n      closeBtn = <td className=\"close\"/>;\n    return (\n      <tr>\n        <td>\n          {formulaInput}\n        </td>\n        <td>\n          {tex && <TeX math={tex} />}\n        </td>\n        <td>\n          {eg && <TeX math={eg} />}\n        </td>\n        { closeBtn }\n      </tr>\n    );\n  }\n\n  render() {\n    let { premises, conclusion } = this.state;\n    return (\n      <div className=\"content full-width\">\n        <h1>Create New</h1>\n        <h2>File Name</h2>\n        <input ref={this.filename}/>\n        <table className=\"formulaTable\">\n          \n        </table>\n        <h2>Premises</h2>\n        <table className=\"formulaTable\">\n          <tbody>\n            <tr>\n                <td>\n                  Formula\n                </td>\n              <td>TeX notation</td><td>EG notation</td><td className=\"close\"/>\n            </tr>\n            {premises.map((formula,i) => this.getFormulaCell(formula, i))}\n            <tr>\n              <td className=\"interactive\" onClick={() => this.setState({ premises: premises.concat(['']) }) }>\n                <span className=\"plus\" />Add New Premise\n              </td>\n              <td/><td/><td className=\"close\"/>\n            </tr>\n          </tbody>\n        </table>\n        <h2>Conclusion</h2>\n        <table className=\"formulaTable\">\n          <tbody>\n            {this.getFormulaCell(conclusion)}\n          </tbody>\n        </table>\n      </div>\n    );\n  }\n}\n\nexport default CreateNew;","import React from 'react';\nimport CreateNew from './CreateNew';\nimport { ReactSVG } from 'react-svg';\nimport './intro.scss';\n\nconst IntroContent = ({ recentDocs }) => (\n  <div className=\"content\">\n    <div className=\"column\">\n      <h1>Existential Graphs</h1>\n      <p>\n        Using this tool, you can initialize proofs in the existential graph schema and then you can go through the process of solving them. You can save these proofs and look back at them later.\n      </p>\n    </div>\n    <div className=\"divider\" />\n    <div className=\"column\">\n      <h1>Recent Proofs</h1>\n      {Object.keys(recentDocs).map(name => (\n        <div className=\"proofField\" style={{ display: 'flex', justifyContent: 'space-between' }} >\n          <span onClick={() => recentDocs[name].open()}>\n            {name}\n          </span>\n          <span \n            style={{ color: 'gray' }} \n            onClick={() => recentDocs[name].delete()}\n          >Delete</span>\n        </div>\n      ))}\n    </div>\n  </div>\n);\n\nclass IntroWindow extends React.Component {\n  constructor(props) {\n    super(props);\n    this.createView = React.createRef();\n    this.callCreate = this.callCreate.bind(this);\n    this.animateAway = this.animateAway.bind(this);\n    this.openFile = this.openFile.bind(this);\n    this.state = {\n      createShown: false,\n      floatingWindowCSS: 'floating-window shown'\n    };\n  }\n\n  componentDidMount() {\n  }\n\n  animateAway() {\n    this.setState({ floatingWindowCSS: 'floating-window' })\n  }\n\n  callCreate() {\n    this.createView.current.create();\n  }\n\n  openFile() {\n    const input = document.createElement(\"input\");\n    input.setAttribute(\"type\", \"file\");\n    input.setAttribute(\"accept\", \".egprf\");\n    input.onchange = (evt) => {\n      console.log(\"ONCHANGE\")\n      evt.stopPropagation();\n      evt.preventDefault();\n      var file = evt.target.files[0];\n      console.log(file);\n      var reader = new FileReader();\n      reader.addEventListener('load', (evt) => {\n        try {\n          let res = JSON.parse(evt.target.result);\n          console.log(res);\n          this.props.setupFunc(file.name.split(\".egprf\")[0], res);\n        } catch (e) {\n          console.error(e);\n          alert(\"Corrupt file or improper formatting.\");\n        }\n      });\n      reader.readAsText(file);\n    };\n    input.click();\n  }\n\n  render() {\n    const { createShown, floatingWindowCSS } = this.state;\n    return (\n      <div className={floatingWindowCSS}>\n        {!createShown && <IntroContent recentDocs={this.props.recentDocs}/>}\n        {createShown && <CreateNew setupFunc={this.props.setupFunc} ref={this.createView}/>}\n          {!createShown && (\n            <div className=\"toolbar\">\n            <button onClick={() => this.setState({ createShown: true })}>\n              New \n            </button>\n            <button onClick={this.openFile}>\n              Open \n            </button>\n            </div>\n          )}\n          {createShown && (\n            <div className=\"toolbar\">\n              <button className=\"back\" onClick={() => this.setState({ createShown: false })}>\n                <span >\n                  <ReactSVG className=\"svg\" src={process.env.PUBLIC_URL + \"/assets/back-caret.svg\"} />\n                </span>\n                Back \n              </button>\n              <button onClick={this.callCreate}>\n                Create \n              </button>\n            </div>\n          )}\n      </div>\n    );\n  }\n}\n\nexport default IntroWindow;","import React from 'react';\nimport './App.scss';\nimport Canvas from './canvas/Canvas';\nimport IntroWindow from './intro/IntroWindow';\n\nvar localStorage = window.localStorage;\n\nclass App extends React.Component {\n  constructor(props) {\n    super(props);\n  \n    this.createNewProof = this.createNewProof.bind(this);\n    this.setupProof = this.setupProof.bind(this);\n    this.openCanvas = this.openCanvas.bind(this);\n    this.saveProof = this.saveProof.bind(this);\n    this.getRecents = this.getRecents.bind(this);\n    this.introWindow = React.createRef();\n    this.state = {\n      initialCSS: 'initial',\n      canvasOpen: false,\n      popupOpen: false,\n      filename: '',\n      proof: {\n        premises: [],\n        conclusion: '',\n        steps: []\n      },\n      recentDocs: this.getRecents()\n    };\n    \n    console.log(this.state.recentDocs)\n    // this.state = {\n    //   initialCSS: 'initial',\n    //   canvasOpen: true,\n    //   popupOpen: false,\n    //   proof: {premises: [\"({Q})(({P}){Q})\"], conclusion: \"{Q}\", steps:[] }\n    // };\n\n    this.menuItems = [\n      { \n        title: 'Exit', \n        func: () => {\n          this.setState({ \n            initialCSS: 'initial',\n            canvasOpen: false,\n            popupOpen: false,\n            filename: '',\n            proof: {\n              premises: [],\n              conclusion: '',\n              steps: []\n            },\n            recentDocs: this.getRecents()\n          }) \n        }\n      },\n      'separator',\n      { \n        title: 'Export',\n        func: () => {\n          const element = document.createElement(\"a\");\n          const file = new Blob([JSON.stringify(this.state.proof)], {type: 'text/plain'});\n          element.href = URL.createObjectURL(file);\n          element.download = this.state.filename + \".egprf\";\n          document.body.appendChild(element);\n          element.click();\n        } \n      }\n    ]\n  }\n\n  getRecents() {\n    let recents = localStorage.getItem('recentDocs');\n    recents = recents ? JSON.parse(recents) : {}\n    let keys = Object.keys(recents)\n    for (let i in keys) {\n      recents[keys[i]].open = () => {\n        this.setState({ \n          filename: keys[i],\n          proof: recents[keys[i]] \n        });\n        this.openCanvas();\n      }\n      recents[keys[i]].delete = () => {\n        let rArray = localStorage.getItem('recentDocs');\n        rArray = rArray ? JSON.parse(rArray) : {}\n        delete rArray[keys[i]];\n        localStorage.setItem('recentDocs', JSON.stringify(rArray));\n        this.setState({ recentDocs: rArray });\n      }\n    }\n    return recents;\n  }\n\n  saveProof(filename) {\n    let { recentDocs } = this.state;\n    recentDocs[filename] = this.state.proof;\n    return (proof) => {\n      recentDocs[filename] = proof;\n      localStorage.setItem('recentDocs', JSON.stringify(recentDocs));\n    }\n  }\n\n  setupProof(filename, proof) {\n    this.setState({ \n      filename: filename,\n      proof: proof\n    });\n    this.openCanvas();\n  }\n\n  openCanvas() {\n    this.setState({ initialCSS: 'initial whiteBG' });\n    this.introWindow.current.animateAway();\n    setTimeout(() => this.setState({ \n      canvasOpen: true\n    }), 1000);\n  }\n\n  createNewProof() {\n    this.setState({ popupOpen: true })\n  }\n\n  render() {\n    if (this.state.canvasOpen) {\n      return (\n        <div className=\"App\">\n          <Canvas \n            menuItems={this.menuItems}\n            saveProof={this.saveProof(this.state.filename)} \n            proof={this.state.proof} />\n        </div>\n      );\n    }\n    return (\n      <div className={this.state.initialCSS}>\n        <IntroWindow \n          ref={this.introWindow} \n          recentDocs={this.state.recentDocs}\n          setupFunc={this.setupProof}/>\n      </div>\n    );\n  }\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.scss';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\n// Root React element, renders the App onload.\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}